/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * vuex v3.0.0
 * (c) 2017 Evan You
 * @license MIT
 */
var applyMixin = function applyMixin(Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if (options === void 0) options = {};

      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit() {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function' ? options.store() : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin(store) {
  if (!devtoolHook) {
    return;
  }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */

/**
 * forEach for object
 */
function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function (key) {
    return fn(obj[key], key);
  });
}

function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

function isPromise(val) {
  return val && typeof val.then === 'function';
}

function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}

var Module = function Module(rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: { configurable: true } };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced;
};

Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};

Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties(Module.prototype, prototypeAccessors$1);

var ModuleCollection = function ModuleCollection(rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function (module, key) {
    return module.getChild(key);
  }, this.root);
};

ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '');
  }, '');
};

ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1 = this;
  if (runtime === void 0) runtime = true;

  if (process.env.NODE_ENV !== 'production') {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) {
    return;
  }

  parent.removeChild(key);
};

function update(path, targetModule, newModule) {
  if (process.env.NODE_ENV !== 'production') {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, " + 'manual reload is needed');
        }
        return;
      }
      update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var functionAssert = {
  assert: function assert(value) {
    return typeof value === 'function';
  },
  expected: 'function'
};

var objectAssert = {
  assert: function assert(value) {
    return typeof value === 'function' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.handler === 'function';
  },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule(path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) {
      return;
    }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));
    });
  });
}

function makeAssertionMessage(path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + path.join('.') + "\"";
  }
  buf += " is " + JSON.stringify(value) + ".";
  return buf;
}

var Vue; // bind on install

var Store = function Store(options) {
  var this$1 = this;
  if (options === void 0) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "Store must be called with the new operator.");
  }

  var plugins = options.plugins;if (plugins === void 0) plugins = [];
  var strict = options.strict;if (strict === void 0) strict = false;

  var state = options.state;if (state === void 0) state = {};
  if (typeof state === 'function') {
    state = state() || {};
  }

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch.call(store, type, payload);
  };
  this.commit = function boundCommit(type, payload, options) {
    return commit.call(store, type, payload, options);
  };

  // strict mode
  this.strict = strict;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) {
    return plugin(this$1);
  });

  if (Vue.config.devtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors = { state: { configurable: true } };

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state;
};

prototypeAccessors.state.set = function (v) {
  if (process.env.NODE_ENV !== 'production') {
    assert(false, "Use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if (process.env.NODE_ENV !== 'production') {
      console.error("[vuex] unknown mutation type: " + type);
    }
    return;
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) {
    return sub(mutation, this$1.state);
  });

  if (process.env.NODE_ENV !== 'production' && options && options.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. " + 'Use the filter functionality in the vue-devtools');
  }
};

Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if (process.env.NODE_ENV !== 'production') {
      console.error("[vuex] unknown action type: " + type);
    }
    return;
  }

  this._actionSubscribers.forEach(function (sub) {
    return sub(action, this$1.state);
  });

  return entry.length > 1 ? Promise.all(entry.map(function (handler) {
    return handler(payload);
  })) : entry[0](payload);
};

Store.prototype.subscribe = function subscribe(fn) {
  return genericSubscribe(fn, this._subscribers);
};

Store.prototype.subscribeAction = function subscribeAction(fn) {
  return genericSubscribe(fn, this._actionSubscribers);
};

Store.prototype.watch = function watch(getter, cb, options) {
  var this$1 = this;

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return this._watcherVM.$watch(function () {
    return getter(this$1.state, this$1.getters);
  }, cb, options);
};

Store.prototype.replaceState = function replaceState(state) {
  var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0) options = {};

  if (typeof path === 'string') {
    path = [path];
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1 = this;

  if (typeof path === 'string') {
    path = [path];
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties(Store.prototype, prototypeAccessors);

function genericSubscribe(fn, subs) {
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  };
}

function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM(store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () {
      return fn(store);
    };
    Object.defineProperty(store.getters, key, {
      get: function get() {
        return store._vm[key];
      },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () {
      return oldVm.$destroy();
    });
  }
}

function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (process.env.NODE_ENV !== 'production' && !store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }

      return store.dispatch(type, payload);
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (process.env.NODE_ENV !== 'production' && !store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function () {
        return store.getters;
      } : function () {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function get() {
        return getNestedState(store.state, path);
      }
    }
  });

  return local;
}

function makeLocalGetters(store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) {
      return;
    }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function get() {
        return store.getters[type];
      },
      enumerable: true
    });
  });

  return gettersProxy;
}

function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload, cb) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err;
      });
    } else {
      return res;
    }
  });
}

function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (process.env.NODE_ENV !== 'production') {
      console.error("[vuex] duplicate getter key: " + type);
    }
    return;
  }
  store._wrappedGetters[type] = function wrappedGetter(store) {
    return rawGetter(local.state, // local state
    local.getters, // local getters
    store.state, // root state
    store.getters // root getters
    );
  };
}

function enableStrictMode(store) {
  store._vm.$watch(function () {
    return this._data.$$state;
  }, function () {
    if (process.env.NODE_ENV !== 'production') {
      assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, sync: true });
}

function getNestedState(state, path) {
  return path.length ? path.reduce(function (state, key) {
    return state[key];
  }, state) : state;
}

function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof type === 'string', "Expects string as the type, but found " + (typeof type === 'undefined' ? 'undefined' : _typeof(type)) + ".");
  }

  return { type: type, payload: payload, options: options };
}

function install(_Vue) {
  if (Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');
    }
    return;
  }
  Vue = _Vue;
  applyMixin(Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return;
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res;
});

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return;
        }
        commit = module.context.commit;
      }
      return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return;
      }
      if (process.env.NODE_ENV !== 'production' && !(val in this.$store.getters)) {
        console.error("[vuex] unknown getter: " + val);
        return;
      }
      return this.$store.getters[val];
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res;
});

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return;
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});

var createNamespacedHelpers = function createNamespacedHelpers(namespace) {
  return {
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
  };
};

function normalizeMap(map) {
  return Array.isArray(map) ? map.map(function (key) {
    return { key: key, val: key };
  }) : Object.keys(map).map(function (key) {
    return { key: key, val: map[key] };
  });
}

function normalizeNamespace(fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map);
  };
}

function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (process.env.NODE_ENV !== 'production' && !module) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace);
  }
  return module;
}

var index_esm = {
  Store: Store,
  install: install,
  version: '3.0.0',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers
};

exports.Store = Store;
exports.install = install;
exports.mapState = mapState;
exports.mapMutations = mapMutations;
exports.mapGetters = mapGetters;
exports.mapActions = mapActions;
exports.createNamespacedHelpers = createNamespacedHelpers;
exports.default = index_esm;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.5.2
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop(a, b, c) {}

/**
 * Always return false.
 */
var no = function no(a, b, c) {
  return false;
};

/**
 * Return same value
 */
var identity = function identity(_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  if (a === b) {
    return true;
  }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = ['component', 'directive', 'filter'];

var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = {}.watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function isServerRendering() {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check
var formatComponentName = noop;

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function classify(str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function warn(msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function tip(msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function formatComponentName(vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function repeat(str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) {
        res += str;
      }
      if (n > 1) {
        str += str;
      }
      n >>= 1;
    }
    return res;
  };

  generateComponentTrace = function generateComponentTrace(vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}

/*  */

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.functionalOptions = undefined;
  this.functionalScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function createEmptyVNode(text) {
  if (text === void 0) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode, deep) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  if (deep && vnode.children) {
    cloned.children = cloneVNodes(vnode.children);
  }
  return cloned;
}

function cloneVNodes(vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }
  return res;
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive(obj, key, val, customSetter, shallow) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

      return parentVal;
    }
    return mergeDataOrFn.call(this, parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }
  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (process.env.NODE_ENV !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && process.env.NODE_ENV !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) {
    extend(ret, childVal);
  }
  return ret;
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  } else if (process.env.NODE_ENV !== 'production') {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
  var inject = options.inject;
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
    }
  } else if (process.env.NODE_ENV !== 'production' && inject) {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (process.env.NODE_ENV !== 'production') {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

/*  */

function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;
    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (process.env.NODE_ENV !== 'production') {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */
  if (inBrowser && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both micro and macro tasks.
// In < 2.4 we used micro tasks everywhere, but there are some scenarios where
// micro tasks have too high a priority and fires in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using macro tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use micro task by default, but expose a way to force macro task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) Task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function macroTimerFunc() {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||
// PhantomJS
MessageChannel.toString() === '[object MessageChannelConstructor]')) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function macroTimerFunc() {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function macroTimerFunc() {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine MicroTask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function microTimerFunc() {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) {
      setTimeout(noop);
    }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a Task instead of a MicroTask.
 */
function withMacroTask(fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res;
  });
}

function nextTick(cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function warnNonPresent(target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function mark(tag) {
      return perf.mark(tag);
    };
    measure = function measure(name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }
  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node;
}

function resolveAsyncComponent(factory, baseCtor, context) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function forceRender() {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(process.env.NODE_ENV !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}

/*  */

function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}

/*  */

function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}

/*  */

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm;
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break;
        }
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (process.env.NODE_ENV !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, "event handler for \"" + event + "\"");
        }
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) && data && data.slot != null) {
      var name = child.data.slot;
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment || node.text === ' ';
}

function resolveScopedSlots(fns, // see flow/vnode
res) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res;
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function updateComponent() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function updateComponent() {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse(val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function loop(key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) {
    loop(key);
  }observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }
      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, keyOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        defineReactive(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
      /* istanbul ignore next */
      return Object.getOwnPropertyDescriptor(inject, key).enumerable;
    }) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (process.env.NODE_ENV !== 'production') {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }
    return result;
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    ret._isVList = true;
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }
      props = extend(extend({}, bindObject), props);
    }
    return scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && process.env.NODE_ENV !== 'production') {
      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      slotNodes._rendered = true;
    }
    return slotNodes || fallback;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias, eventKeyName) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (keyCodes) {
    if (Array.isArray(keyCodes)) {
      return keyCodes.indexOf(eventKeyCode) === -1;
    } else {
      return keyCodes !== eventKeyCode;
    }
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function loop(key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) {
        loop(key);
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  // static trees can be rendered once and cached on the contructor options
  // so every instance shares the same cached trees
  var renderFns = this.$options.staticRenderFns;
  var cached = renderFns.cached || (renderFns.cached = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = renderFns[index].call(this._renderProxy, null, this);
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data;
}

/*  */

function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var options = Ctor.options;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    return resolveSlots(children, parent);
  };

  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm = Object.create(parent);
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode) {
        vnode.functionalScopeId = options._scopeId;
        vnode.functionalContext = parent;
      }
      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }
    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    vnode.functionalContext = contextVm;
    vnode.functionalOptions = options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }

  return vnode;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options);
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {
        applyNS(child, ns, force);
      }
    }
  }
}

/*  */

function initRender(vm) {
  vm._vnode = null; // the root of the child tree
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (var key in vm.$slots) {
        var slot = vm.$slots[key];
        if (slot._rendered) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */);
        }
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };
}

/*  */

var uid = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
      }
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && config.isReservedTag(id)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];
  if (cached$$1 && cached$$1 !== current) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
        return vnode;
      }

      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode;
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
});

Vue$3.version = '2.5.2';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function mustUseProp(tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function isXlink(name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function getXlinkProp(name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function isFalsyAttrValue(val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject(value)) {
    return stringifyObject(value);
  }
  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */
  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }
      res += stringified;
    }
  }
  return res;
}

function stringifyObject(value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }
      res += key;
    }
  }
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isReservedTag = function isReservedTag(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove() {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          inPre++;
        }
        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore) ? ignore.test(tag) : ignore === tag;
        })) && config.isUnknownElement(tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    if (isDef(i = vnode.functionalScopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setAttribute(vnode.elm, i, '');
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.functionalContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        } else {
          vnodeToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !vnodeToMove) {
            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
          }
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode)) {
        return false;
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (process.env.NODE_ENV !== 'production') {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function callInsert() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE9 || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

/*  */

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.

/*  */

/**
 * Cross-platform code generation for component v-model
 */

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler(handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler() {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
}

function add$1(event, handler, once$$1, capture, passive) {
  handler = withMacroTask(handler);
  if (once$$1) {
    handler = createOnceHandler(handler, event, capture);
  }
  target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
}

function isDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}
  return notInFocus && elm.value !== checkVal;
}

function isInputChanged(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number) {
    return toNumber(value) !== toNumber(newVal);
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim();
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function setProp(el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition(def) {
  if (!def) {
    return;
  }
  /* istanbul ignore else */
  if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res;
  } else if (typeof def === 'string') {
    return autoCssTransition(def);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function end() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function onEnd(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return rm();
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$options._renderChildren;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag || isAsyncPlaceholder(c);
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave;
        var performLeave = function performLeave() {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
Vue$3.nextTick(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

exports.default = Vue$3;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(4), __webpack_require__(8).setImmediate))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(21)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__(3);

var _vue2 = _interopRequireDefault(_vue);

var _store = __webpack_require__(10);

var _store2 = _interopRequireDefault(_store);

var _engine = __webpack_require__(15);

var _engine2 = _interopRequireDefault(_engine);

var _Main = __webpack_require__(18);

var _Main2 = _interopRequireDefault(_Main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var application = new _vue2.default({
  el: '#main',
  store: _store2.default,
  render: function render(handler) {
    return handler(_Main2.default);
  }
});

_engine2.default.start(_store2.default);

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(9);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(1)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(3);

var _vue2 = _interopRequireDefault(_vue);

var _vuex = __webpack_require__(2);

var _vuex2 = _interopRequireDefault(_vuex);

var _state = __webpack_require__(11);

var _state2 = _interopRequireDefault(_state);

var _mutations = __webpack_require__(12);

var _mutations2 = _interopRequireDefault(_mutations);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vuex2.default);

exports.default = new _vuex2.default.Store({ state: _state2.default, mutations: _mutations2.default });

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var clip = {
  count: 0,
  stock: 0,
  price: 0.25
};

var variation = {
  demand: 0.01,
  clipPrice: 0.01,
  wirePrice: 0.2
};

var wire = {
  stock: 1000,
  batchSize: 1000,
  basePrice: 14
};

var stats = {
  funds: 0,
  demand: 0.3
};

module.exports = { clip: clip, variation: variation, wire: wire, stats: stats };

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var production = __webpack_require__(13);
var pricing = __webpack_require__(14);

module.exports = {
  PRODUCE_CLIP: production.produce,
  SELL_CLIP: production.sell,
  INCREASE_PRICE: pricing.increase,
  DECREASE_PRICE: pricing.decrease
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  produce: function produce(state) {
    if (state.wire.stock > 0) {
      state.clip.count++;
      state.clip.stock++;
      state.wire.stock--;
    }
  },
  sell: function sell(state) {
    if (state.clip.stock > 0) {
      state.clip.stock--;
      state.stats.funds += state.clip.price;
    }
  }
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  increase: function increase(state) {
    state.clip.price += state.variation.clipPrice;
    state.stats.demand = state.stats.demand - state.stats.demand * state.variation.demand;
  },
  decrease: function decrease(state) {
    if (state.clip.price > 0.01) {
      state.clip.price -= state.variation.clipPrice;
      state.stats.demand = state.stats.demand + state.stats.demand * state.variation.demand;
    }
  }
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var chances = __webpack_require__(16);
var sales = __webpack_require__(17)(chances);

module.exports = {
  start: function start(store) {
    console.log('Starting Engine');
    var engineLoop = setInterval(function () {
      sales.start(store);
    }, 1000);
  }
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
  var generator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math;
  return generator.random();
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (chances) {
  return {
    start: function start(store) {
      var chance = chances();
      if (chance <= store.state.stats.demand) {
        console.log('Sale for demand ' + store.state.stats.demand + ' with chance ' + chance);
        return store.commit('SELL_CLIP');
      }

      console.log('No sell for rate ' + store.state.stats.demand + ' with chance ' + chance);
    }
  };
};

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_Main_vue__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_Main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_Main_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2d9016fc_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_Main_vue__ = __webpack_require__(39);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(19)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_Main_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2d9016fc_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_Main_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/Main.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2d9016fc", Component.options)
  } else {
    hotAPI.reload("data-v-2d9016fc", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(20);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(6)("4c16b596", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-2d9016fc\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./Main.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-2d9016fc\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./Main.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(5)(true);
// imports


// module
exports.push([module.i, "\n* {\n  font-family: 'Open Sans', sans-serif;\n}\nh1, h2, h3, h4, h5, h6 {\n  text-transform: uppercase;\n  font-weight: bold;\n}\n", "", {"version":3,"sources":["/Users/conference/wspace/side-projects/paper-clips/src/components/src/components/Main.vue?1644d425"],"names":[],"mappings":";AAuBA;EACA,qCAAA;CACA;AAEA;EACA,0BAAA;EACA,kBAAA;CACA","file":"Main.vue","sourcesContent":["<template>\n  <div>\n    <ClipCounter></ClipCounter>\n    <ProduceClip></ProduceClip>\n    <h3>Operations</h3>\n    <OperationStatus></OperationStatus>\n    <h3>Manufacturing</h3>\n    <WireStatus></WireStatus>\n  </div>\n</template>\n\n<script>\nimport ClipCounter from './ClipCounter.vue'\nimport ProduceClip from './ProduceClip.vue'\nimport OperationStatus from './OperationStatus.vue'\nimport WireStatus from './WireStatus.vue'\n\nexport default {\n  components: {ClipCounter, ProduceClip, OperationStatus, WireStatus}\n}\n</script>\n\n<style>\n* {\n  font-family: 'Open Sans', sans-serif;\n}\n\nh1, h2, h3, h4, h5, h6 {\n  text-transform: uppercase;\n  font-weight: bold;\n}\n</style>\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] });
    } else {
      newStyles[id].parts.push(part);
    }
  }
  return styles;
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ClipCounter = __webpack_require__(23);

var _ClipCounter2 = _interopRequireDefault(_ClipCounter);

var _ProduceClip = __webpack_require__(28);

var _ProduceClip2 = _interopRequireDefault(_ProduceClip);

var _OperationStatus = __webpack_require__(31);

var _OperationStatus2 = _interopRequireDefault(_OperationStatus);

var _WireStatus = __webpack_require__(37);

var _WireStatus2 = _interopRequireDefault(_WireStatus);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  components: { ClipCounter: _ClipCounter2.default, ProduceClip: _ProduceClip2.default, OperationStatus: _OperationStatus2.default, WireStatus: _WireStatus2.default }
};

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ClipCounter_vue__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ClipCounter_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ClipCounter_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2800c399_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_ClipCounter_vue__ = __webpack_require__(27);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(24)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ClipCounter_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2800c399_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_ClipCounter_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/ClipCounter.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2800c399", Component.options)
  } else {
    hotAPI.reload("data-v-2800c399", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(25);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(6)("32becd2f", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-2800c399\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./ClipCounter.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-2800c399\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./ClipCounter.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(5)(true);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n", "", {"version":3,"sources":[],"names":[],"mappings":"","file":"ClipCounter.vue","sourceRoot":""}]);

// exports


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
//
//
//
//


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("h1", [
    _vm._v("Clips produced: " + _vm._s(_vm.$store.state.clip.count))
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2800c399", esExports)
  }
}

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ProduceClip_vue__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ProduceClip_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ProduceClip_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_f0887546_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_ProduceClip_vue__ = __webpack_require__(30);
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ProduceClip_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_f0887546_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_ProduceClip_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/ProduceClip.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-f0887546", Component.options)
  } else {
    hotAPI.reload("data-v-f0887546", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vuex = __webpack_require__(2);

exports.default = {
  methods: (0, _vuex.mapMutations)(['PRODUCE_CLIP'])
}; //
//
//
//
//
//

/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _c(
      "button",
      {
        attrs: { disabled: _vm.$store.state.wire.stock < 1 },
        on: { click: _vm.PRODUCE_CLIP }
      },
      [_vm._v("Produce Paperclip")]
    )
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-f0887546", esExports)
  }
}

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_OperationStatus_vue__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_OperationStatus_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_OperationStatus_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_96cacb74_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_OperationStatus_vue__ = __webpack_require__(36);
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_OperationStatus_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_96cacb74_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_OperationStatus_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/OperationStatus.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-96cacb74", Component.options)
  } else {
    hotAPI.reload("data-v-96cacb74", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ClipPriceControl = __webpack_require__(33);

var _ClipPriceControl2 = _interopRequireDefault(_ClipPriceControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: { ClipPriceControl: _ClipPriceControl2.default }
}; //
//
//
//
//
//
//
//
//
//

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ClipPriceControl_vue__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ClipPriceControl_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ClipPriceControl_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_25b53af2_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_ClipPriceControl_vue__ = __webpack_require__(35);
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_ClipPriceControl_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_25b53af2_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_ClipPriceControl_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/ClipPriceControl.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-25b53af2", Component.options)
  } else {
    hotAPI.reload("data-v-25b53af2", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vuex = __webpack_require__(2);

exports.default = {
  methods: (0, _vuex.mapMutations)(['INCREASE_PRICE', 'DECREASE_PRICE'])
}; //
//
//
//
//
//
//

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _c(
      "button",
      {
        attrs: { disabled: _vm.$store.state.clip.price <= 0.01 },
        on: { click: _vm.DECREASE_PRICE }
      },
      [_vm._v("Reduce Price")]
    ),
    _vm._v(" "),
    _c("button", { on: { click: _vm.INCREASE_PRICE } }, [
      _vm._v("Increase Price")
    ])
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-25b53af2", esExports)
  }
}

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    [
      _c("p", [
        _vm._v(
          "Available funds: $" +
            _vm._s(parseFloat(_vm.$store.state.stats.funds).toFixed(2))
        )
      ]),
      _vm._v(" "),
      _c("p", [_vm._v("Stock count: " + _vm._s(_vm.$store.state.clip.stock))]),
      _vm._v(" "),
      _c("p", [
        _vm._v(
          "Clip Price: " +
            _vm._s(parseFloat(_vm.$store.state.clip.price).toFixed(2))
        )
      ]),
      _vm._v(" "),
      _c("p", [
        _vm._v(
          "Public Demand: " +
            _vm._s(parseFloat(_vm.$store.state.stats.demand * 100).toFixed(2)) +
            "%"
        )
      ]),
      _vm._v(" "),
      _c("ClipPriceControl")
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-96cacb74", esExports)
  }
}

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_template_compiler_index_id_data_v_45658a4c_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_WireStatus_vue__ = __webpack_require__(38);
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */
var __vue_script__ = null
/* template */

/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_template_compiler_index_id_data_v_45658a4c_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_WireStatus_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/WireStatus.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-45658a4c", Component.options)
  } else {
    hotAPI.reload("data-v-45658a4c", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { attrs: { id: "wire-status" } }, [
    _c("p", [_vm._v("Wire stock: " + _vm._s(_vm.$store.state.wire.stock))]),
    _vm._v(" "),
    _c("p", [
      _vm._v(
        "Batch Price: $" +
          _vm._s(_vm.$store.state.wire.basePrice.toFixed(2)) +
          " for " +
          _vm._s(_vm.$store.state.wire.batchSize) +
          " inches"
      )
    ]),
    _vm._v(" "),
    _c("button", [_vm._v("Buy")])
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-45658a4c", esExports)
  }
}

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    [
      _c("ClipCounter"),
      _vm._v(" "),
      _c("ProduceClip"),
      _vm._v(" "),
      _c("h3", [_vm._v("Operations")]),
      _vm._v(" "),
      _c("OperationStatus"),
      _vm._v(" "),
      _c("h3", [_vm._v("Manufacturing")]),
      _vm._v(" "),
      _c("WireStatus")
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2d9016fc", esExports)
  }
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMTdkNjlhZmRhM2RkZGNjMTYzZmYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZXgvZGlzdC92dWV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9zdG9yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RvcmUvc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0b3JlL211dGF0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RvcmUvbXV0YXRpb25zL3Byb2R1Y3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0b3JlL211dGF0aW9ucy9wcmljaW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9jaGFuY2VzLmpzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvc2FsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWFpbi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWFpbi52dWU/ZTU2YyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NYWluLnZ1ZT9hYmE2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL01haW4udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NsaXBDb3VudGVyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9DbGlwQ291bnRlci52dWU/YjY0YiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9DbGlwQ291bnRlci52dWU/MzY1YyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9DbGlwQ291bnRlci52dWU/NGRjYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Qcm9kdWNlQ2xpcC52dWUiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1Byb2R1Y2VDbGlwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Qcm9kdWNlQ2xpcC52dWU/ZGNmMiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9PcGVyYXRpb25TdGF0dXMudnVlIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9PcGVyYXRpb25TdGF0dXMudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NsaXBQcmljZUNvbnRyb2wudnVlIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9DbGlwUHJpY2VDb250cm9sLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9DbGlwUHJpY2VDb250cm9sLnZ1ZT9hNjRjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL09wZXJhdGlvblN0YXR1cy52dWU/ZWIyMiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9XaXJlU3RhdHVzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9XaXJlU3RhdHVzLnZ1ZT9kYTk5Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01haW4udnVlPzM5M2MiXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJhcHBseU1peGluIiwiVnVlIiwiTnVtYmVyIiwic3BsaXQiLCJtaXhpbiIsImJlZm9yZUNyZWF0ZSIsInZ1ZXhJbml0IiwiX2luaXQiLCJvcHRpb25zIiwiaW5pdCIsIiRvcHRpb25zIiwic3RvcmUiLCIkc3RvcmUiLCJwYXJlbnQiLCJkZXZ0b29sSG9vayIsIndpbmRvdyIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJkZXZ0b29sUGx1Z2luIiwiX2RldnRvb2xIb29rIiwidGFyZ2V0U3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJzdWJzY3JpYmUiLCJtdXRhdGlvbiIsInN0YXRlIiwiZm9yRWFjaFZhbHVlIiwib2JqIiwiZm4iLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImlzT2JqZWN0IiwiaXNQcm9taXNlIiwidmFsIiwidGhlbiIsImFzc2VydCIsImNvbmRpdGlvbiIsIm1zZyIsIk1vZHVsZSIsInJhd01vZHVsZSIsInJ1bnRpbWUiLCJfY2hpbGRyZW4iLCJjcmVhdGUiLCJfcmF3TW9kdWxlIiwicmF3U3RhdGUiLCJwcm90b3R5cGVBY2Nlc3NvcnMkMSIsIm5hbWVzcGFjZWQiLCJjb25maWd1cmFibGUiLCJnZXQiLCJhZGRDaGlsZCIsInJlbW92ZUNoaWxkIiwiZ2V0Q2hpbGQiLCJ1cGRhdGUiLCJhY3Rpb25zIiwibXV0YXRpb25zIiwiZ2V0dGVycyIsImZvckVhY2hDaGlsZCIsImZvckVhY2hHZXR0ZXIiLCJmb3JFYWNoQWN0aW9uIiwiZm9yRWFjaE11dGF0aW9uIiwiZGVmaW5lUHJvcGVydGllcyIsIk1vZHVsZUNvbGxlY3Rpb24iLCJyYXdSb290TW9kdWxlIiwicmVnaXN0ZXIiLCJwYXRoIiwicmVkdWNlIiwicm9vdCIsImdldE5hbWVzcGFjZSIsIm5hbWVzcGFjZSIsInVwZGF0ZSQxIiwidGhpcyQxIiwiTk9ERV9FTlYiLCJhc3NlcnRSYXdNb2R1bGUiLCJuZXdNb2R1bGUiLCJzbGljZSIsIm1vZHVsZXMiLCJyYXdDaGlsZE1vZHVsZSIsInVucmVnaXN0ZXIiLCJ0YXJnZXRNb2R1bGUiLCJjb25zb2xlIiwid2FybiIsImZ1bmN0aW9uQXNzZXJ0IiwidmFsdWUiLCJleHBlY3RlZCIsIm9iamVjdEFzc2VydCIsImhhbmRsZXIiLCJhc3NlcnRUeXBlcyIsImFzc2VydE9wdGlvbnMiLCJ0eXBlIiwibWFrZUFzc2VydGlvbk1lc3NhZ2UiLCJidWYiLCJqb2luIiwiSlNPTiIsInN0cmluZ2lmeSIsIlN0b3JlIiwiaW5zdGFsbCIsIlByb21pc2UiLCJwbHVnaW5zIiwic3RyaWN0IiwiX2NvbW1pdHRpbmciLCJfYWN0aW9ucyIsIl9hY3Rpb25TdWJzY3JpYmVycyIsIl9tdXRhdGlvbnMiLCJfd3JhcHBlZEdldHRlcnMiLCJfbW9kdWxlcyIsIl9tb2R1bGVzTmFtZXNwYWNlTWFwIiwiX3N1YnNjcmliZXJzIiwiX3dhdGNoZXJWTSIsInJlZiIsImRpc3BhdGNoIiwiY29tbWl0IiwiYm91bmREaXNwYXRjaCIsInBheWxvYWQiLCJib3VuZENvbW1pdCIsImluc3RhbGxNb2R1bGUiLCJyZXNldFN0b3JlVk0iLCJwbHVnaW4iLCJjb25maWciLCJkZXZ0b29scyIsInByb3RvdHlwZUFjY2Vzc29ycyIsIl92bSIsIl9kYXRhIiwiJCRzdGF0ZSIsInNldCIsInYiLCJfdHlwZSIsIl9wYXlsb2FkIiwiX29wdGlvbnMiLCJ1bmlmeU9iamVjdFN0eWxlIiwiZW50cnkiLCJlcnJvciIsIl93aXRoQ29tbWl0IiwiY29tbWl0SXRlcmF0b3IiLCJzdWIiLCJzaWxlbnQiLCJhY3Rpb24iLCJhbGwiLCJtYXAiLCJnZW5lcmljU3Vic2NyaWJlIiwic3Vic2NyaWJlQWN0aW9uIiwid2F0Y2giLCJnZXR0ZXIiLCJjYiIsIiR3YXRjaCIsInJlZ2lzdGVyTW9kdWxlIiwiaXNBcnJheSIsInByZXNlcnZlU3RhdGUiLCJ1bnJlZ2lzdGVyTW9kdWxlIiwicGFyZW50U3RhdGUiLCJnZXROZXN0ZWRTdGF0ZSIsImRlbGV0ZSIsInJlc2V0U3RvcmUiLCJob3RVcGRhdGUiLCJuZXdPcHRpb25zIiwiY29tbWl0dGluZyIsInN1YnMiLCJpbmRleE9mIiwic3BsaWNlIiwiaG90Iiwib2xkVm0iLCJ3cmFwcGVkR2V0dGVycyIsImNvbXB1dGVkIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZGF0YSIsImVuYWJsZVN0cmljdE1vZGUiLCIkZGVzdHJveSIsInJvb3RTdGF0ZSIsImlzUm9vdCIsIm1vZHVsZU5hbWUiLCJsb2NhbCIsImNvbnRleHQiLCJtYWtlTG9jYWxDb250ZXh0IiwibmFtZXNwYWNlZFR5cGUiLCJyZWdpc3Rlck11dGF0aW9uIiwicmVnaXN0ZXJBY3Rpb24iLCJyZWdpc3RlckdldHRlciIsImNoaWxkIiwibm9OYW1lc3BhY2UiLCJtYWtlTG9jYWxHZXR0ZXJzIiwiZ2V0dGVyc1Byb3h5Iiwic3BsaXRQb3MiLCJsb2NhbFR5cGUiLCJ3cmFwcGVkTXV0YXRpb25IYW5kbGVyIiwid3JhcHBlZEFjdGlvbkhhbmRsZXIiLCJyZXMiLCJyb290R2V0dGVycyIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsInJhd0dldHRlciIsIndyYXBwZWRHZXR0ZXIiLCJkZWVwIiwic3luYyIsIl9WdWUiLCJtYXBTdGF0ZSIsIm5vcm1hbGl6ZU5hbWVzcGFjZSIsInN0YXRlcyIsIm5vcm1hbGl6ZU1hcCIsIm1hcHBlZFN0YXRlIiwiZ2V0TW9kdWxlQnlOYW1lc3BhY2UiLCJ2dWV4IiwibWFwTXV0YXRpb25zIiwibWFwcGVkTXV0YXRpb24iLCJtYXBHZXR0ZXJzIiwibWFwcGVkR2V0dGVyIiwibWFwQWN0aW9ucyIsIm1hcHBlZEFjdGlvbiIsImNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzIiwiYmluZCIsImNoYXJBdCIsImhlbHBlciIsImluZGV4X2VzbSIsImlzVW5kZWYiLCJ1bmRlZmluZWQiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsIl90b1N0cmluZyIsInRvU3RyaW5nIiwidG9SYXdUeXBlIiwiaXNQbGFpbk9iamVjdCIsImlzUmVnRXhwIiwiaXNWYWxpZEFycmF5SW5kZXgiLCJuIiwicGFyc2VGbG9hdCIsIlN0cmluZyIsIk1hdGgiLCJmbG9vciIsImlzRmluaXRlIiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibGlzdCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwiY2FjaGVkIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiX2xlbmd0aCIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJ0b09iamVjdCIsImIiLCJubyIsImlkZW50aXR5IiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheUIiLCJldmVyeSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwicHJvZHVjdGlvblRpcCIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiX2xpZmVjeWNsZUhvb2tzIiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsIndyaXRhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwidGVzdCIsInNlZ21lbnRzIiwiaGFzUHJvdG8iLCJpbkJyb3dzZXIiLCJVQSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJuYXRpdmVXYXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJWVUVfRU5WIiwiaXNOYXRpdmUiLCJDdG9yIiwiaGFzU3ltYm9sIiwiU3ltYm9sIiwiUmVmbGVjdCIsIm93bktleXMiLCJfU2V0IiwiU2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ0aXAiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJ2bSIsInRyYWNlIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsImNpZCIsIl9pc1Z1ZSIsImNvbnN0cnVjdG9yIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsInVpZCQxIiwiRGVwIiwiaWQiLCJhZGRTdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJjb21wb25lbnRPcHRpb25zIiwiYXN5bmNGYWN0b3J5IiwibnMiLCJmdW5jdGlvbmFsQ29udGV4dCIsImZ1bmN0aW9uYWxPcHRpb25zIiwiZnVuY3Rpb25hbFNjb3BlSWQiLCJjb21wb25lbnRJbnN0YW5jZSIsInJhdyIsImlzU3RhdGljIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJhc3luY01ldGEiLCJpc0FzeW5jUGxhY2Vob2xkZXIiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJ2bm9kZSIsImNsb25lZCIsImNsb25lVk5vZGVzIiwidm5vZGVzIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsInJlc3VsdCIsIm9iIiwiX19vYl9fIiwiaW5zZXJ0ZWQiLCJvYnNlcnZlQXJyYXkiLCJkZXAiLCJhcnJheUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwib2JzZXJ2ZXJTdGF0ZSIsInNob3VsZENvbnZlcnQiLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUiLCJpdGVtcyIsIm9ic2VydmUiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsIm1heCIsImRlbCIsInN0cmF0cyIsImVsIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJhc3NlcnRPYmplY3RUeXBlIiwia2V5JDEiLCJwcm9wcyIsIm1ldGhvZHMiLCJpbmplY3QiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsImxvd2VyIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImhhbmRsZUVycm9yIiwiaW5mbyIsImN1ciIsImhvb2tzIiwiZXJyb3JDYXB0dXJlZCIsImNhcHR1cmUiLCJnbG9iYWxIYW5kbGVFcnJvciIsImxvZ0Vycm9yIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwibWljcm9UaW1lckZ1bmMiLCJtYWNyb1RpbWVyRnVuYyIsInVzZU1hY3JvVGFzayIsInNldEltbWVkaWF0ZSIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQiLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJwIiwid2l0aE1hY3JvVGFzayIsIl93aXRoVGFzayIsIl9yZXNvbHZlIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5IiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbGRPbiIsInJlbW92ZSQkMSIsIm9sZCIsImV2ZW50IiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwibWVyZ2VkIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJoYXNoIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsImxhc3RJbmRleCIsInNoaWZ0IiwiX2lzVkxpc3QiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwidG9TdHJpbmdUYWciLCJjcmVhdGVBc3luY1BsYWNlaG9sZGVyIiwiZmFjdG9yeSIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImJhc2VDdG9yIiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJjb250ZXh0cyIsImZvcmNlUmVuZGVyIiwiJGZvcmNlVXBkYXRlIiwicmVqZWN0IiwicmVhc29uIiwiY29tcG9uZW50IiwiZGVsYXkiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwiX3BhcmVudExpc3RlbmVycyIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbmNlIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCJjYnMiLCJpJDEiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJkZWZhdWx0U2xvdCIsInNsb3QiLCJpc1doaXRlc3BhY2UiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJhY3RpdmVJbnN0YW5jZSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsImluaXRMaWZlY3ljbGUiLCJhYnN0cmFjdCIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJoeWRyYXRpbmciLCJjYWxsSG9vayIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsIl92bm9kZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9wYXJlbnRFbG0iLCJfcmVmRWxtIiwiX192dWVfXyIsIiR2bm9kZSIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJhY3RpdmF0ZWRDaGlsZHJlbiIsImNpcmN1bGFyIiwid2FpdGluZyIsImZsdXNoaW5nIiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwic29ydCIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJsYXp5IiwiYWN0aXZlIiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsInRyYXZlcnNlIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2Vlbk9iamVjdHMiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiZGVwSWQiLCJzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24iLCJwcm94eSIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwicHJvcHNPcHRpb25zIiwibG9vcCIsImh5cGhlbmF0ZWRLZXkiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsIiRkYXRhIiwic2hvdWxkQ2FjaGUiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlV2F0Y2hlciIsImtleU9yRm4iLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJmaWx0ZXIiLCJwcm92aWRlS2V5Iiwic291cmNlIiwicHJvdmlkZURlZmF1bHQiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiZXZlbnRLZXlOYW1lIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwicmVuZGVyRm5zIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImluamVjdGlvbnMiLCJjb250ZXh0Vm0iLCJpc0NvbXBpbGVkIiwiX2NvbXBpbGVkIiwibmVlZE5vcm1hbGl6YXRpb24iLCJfc2NvcGVJZCIsIl9jIiwiZCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsInJlbmRlckNvbnRleHQiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwicGFyZW50RWxtIiwicmVmRWxtIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsIiRtb3VudCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJvbGRWbm9kZSIsImluc2VydCIsImRlc3Ryb3kiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJfYmFzZSIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm5hdGl2ZU9uIiwibWVyZ2VIb29rcyIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwiZnJvbVBhcmVudCIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJmb3JjZSIsImluaXRSZW5kZXIiLCIkY3JlYXRlRWxlbWVudCIsInBhcmVudERhdGEiLCJyZW5kZXJNaXhpbiIsIiRuZXh0VGljayIsInJlbmRlckVycm9yIiwidWlkIiwiaW5pdE1peGluIiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJleHRlbmRlZCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJWdWUkMyIsImluaXRVc2UiLCJ1c2UiLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5pdE1peGluJDEiLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiUmVnRXhwIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwic3NyQ29udGV4dCIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJkb2N1bWVudCIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwicXVlcnkiLCJzZWxlY3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpblByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNvbWUiLCJpZ25vcmUiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJyZWYkJDEiLCJhbmNlc3RvciIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsInZub2RlVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJmaW5kSWR4SW5PbGQiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJiYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwiaSQyIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwiaW5oZXJpdEF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyIiwib25jZUhhbmRsZXIiLCJyZW1vdmUkMiIsImFkZCQxIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZURPTUxpc3RlbmVycyIsImV2ZW50cyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNEaXJ0eSIsImlzSW5wdXRDaGFuZ2VkIiwibm90SW5Gb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsIm51bWJlciIsInRyaW0iLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJzdHlsZSIsIm5vcm1hbGl6ZVN0eWxlQmluZGluZyIsInN0YXRpY1N0eWxlIiwiYmluZGluZ1N0eWxlIiwiZ2V0U3R5bGUiLCJjaGVja0NoaWxkIiwic3R5bGVEYXRhIiwiY3NzVmFyUkUiLCJpbXBvcnRhbnRSRSIsInNldFByb3AiLCJzZXRQcm9wZXJ0eSIsIm5vcm1hbGl6ZWROYW1lIiwibm9ybWFsaXplIiwidmVuZG9yTmFtZXMiLCJlbXB0eVN0eWxlIiwiY2FwTmFtZSIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJub3JtYWxpemVkU3R5bGUiLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwiYWRkQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ0cmFuc2l0aW9uQ2xhc3NlcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJzIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImJlZm9yZUVudGVyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJzdGFydENsYXNzIiwiYWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJ0cmlnZ2VyIiwibW9kZWwkMSIsInNldFNlbGVjdGVkIiwiX3ZPcHRpb25zIiwiZ2V0VmFsdWUiLCJvbkNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvblN0YXJ0IiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJnIiwiRnVuY3Rpb24iLCJldmFsIiwidXNlU291cmNlTWFwIiwiY29udGVudCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImNzc01hcHBpbmciLCJidG9hIiwic291cmNlTWFwcGluZyIsInRvQ29tbWVudCIsInNvdXJjZVVSTHMiLCJzb3VyY2VzIiwic291cmNlUm9vdCIsInNvdXJjZU1hcCIsImJhc2U2NCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiYXBwbGljYXRpb24iLCJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY2xvc2UiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsImVucm9sbCIsIm1zZWNzIiwiX2lkbGVUaW1lb3V0SWQiLCJfaWRsZVRpbWVvdXQiLCJ1bmVucm9sbCIsIl91bnJlZkFjdGl2ZSIsIm9uVGltZW91dCIsIl9vblRpbWVvdXQiLCJyZXF1aXJlIiwiY2xlYXJJbW1lZGlhdGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsImhhbmRsZSIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJpbXBvcnRTY3JpcHRzIiwicG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyIsIm9sZE9uTWVzc2FnZSIsImluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uIiwibWVzc2FnZVByZWZpeCIsInJhbmRvbSIsIm9uR2xvYmFsTWVzc2FnZSIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwiaHRtbCIsImRvY3VtZW50RWxlbWVudCIsInNjcmlwdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsImdldFByb3RvdHlwZU9mIiwic2VsZiIsImNsaXAiLCJjb3VudCIsInN0b2NrIiwicHJpY2UiLCJ2YXJpYXRpb24iLCJkZW1hbmQiLCJjbGlwUHJpY2UiLCJ3aXJlUHJpY2UiLCJ3aXJlIiwiYmF0Y2hTaXplIiwiYmFzZVByaWNlIiwic3RhdHMiLCJmdW5kcyIsInByb2R1Y3Rpb24iLCJwcmljaW5nIiwiUFJPRFVDRV9DTElQIiwicHJvZHVjZSIsIlNFTExfQ0xJUCIsInNlbGwiLCJJTkNSRUFTRV9QUklDRSIsImluY3JlYXNlIiwiREVDUkVBU0VfUFJJQ0UiLCJkZWNyZWFzZSIsImNoYW5jZXMiLCJzYWxlcyIsImxvZyIsImVuZ2luZUxvb3AiLCJnZW5lcmF0b3IiLCJjaGFuY2UiLCJsaXN0VG9TdHlsZXMiLCJwYXJlbnRJZCIsIm5ld1N0eWxlcyIsIm1lZGlhIiwicGFydCIsInBhcnRzIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7O0FDN0NBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3SztBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHdEQUF3RCxJQUFJOztBQUUzSTtBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOzs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLG9CQUFvQixFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQyIsImZpbGUiOiJkaXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMTdkNjlhZmRhM2RkZGNjMTYzZmYiLCIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIgLyogc2VydmVyIG9ubHkgKi9cbikge1xuICB2YXIgZXNNb2R1bGVcbiAgdmFyIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyB8fCB7fVxuXG4gIC8vIEVTNiBtb2R1bGVzIGludGVyb3BcbiAgdmFyIHR5cGUgPSB0eXBlb2YgcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXNNb2R1bGUgPSByYXdTY3JpcHRFeHBvcnRzXG4gICAgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICB9XG5cbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWRUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIHZhciBmdW5jdGlvbmFsID0gb3B0aW9ucy5mdW5jdGlvbmFsXG4gICAgdmFyIGV4aXN0aW5nID0gZnVuY3Rpb25hbFxuICAgICAgPyBvcHRpb25zLnJlbmRlclxuICAgICAgOiBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuXG4gICAgaWYgKCFmdW5jdGlvbmFsKSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlc01vZHVsZTogZXNNb2R1bGUsXG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLyoqXG4gKiB2dWV4IHYzLjAuMFxuICogKGMpIDIwMTcgRXZhbiBZb3VcbiAqIEBsaWNlbnNlIE1JVFxuICovXG52YXIgYXBwbHlNaXhpbiA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgdmFyIHZlcnNpb24gPSBOdW1iZXIoVnVlLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG5cbiAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgIFZ1ZS5taXhpbih7IGJlZm9yZUNyZWF0ZTogdnVleEluaXQgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3ZlcnJpZGUgaW5pdCBhbmQgaW5qZWN0IHZ1ZXggaW5pdCBwcm9jZWR1cmVcbiAgICAvLyBmb3IgMS54IGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgIHZhciBfaW5pdCA9IFZ1ZS5wcm90b3R5cGUuX2luaXQ7XG4gICAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgICAgb3B0aW9ucy5pbml0ID0gb3B0aW9ucy5pbml0XG4gICAgICAgID8gW3Z1ZXhJbml0XS5jb25jYXQob3B0aW9ucy5pbml0KVxuICAgICAgICA6IHZ1ZXhJbml0O1xuICAgICAgX2luaXQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZ1ZXggaW5pdCBob29rLCBpbmplY3RlZCBpbnRvIGVhY2ggaW5zdGFuY2VzIGluaXQgaG9va3MgbGlzdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gdnVleEluaXQgKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAvLyBzdG9yZSBpbmplY3Rpb25cbiAgICBpZiAob3B0aW9ucy5zdG9yZSkge1xuICAgICAgdGhpcy4kc3RvcmUgPSB0eXBlb2Ygb3B0aW9ucy5zdG9yZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9wdGlvbnMuc3RvcmUoKVxuICAgICAgICA6IG9wdGlvbnMuc3RvcmU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC4kc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldnRvb2xIb29rID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbmZ1bmN0aW9uIGRldnRvb2xQbHVnaW4gKHN0b3JlKSB7XG4gIGlmICghZGV2dG9vbEhvb2spIHsgcmV0dXJuIH1cblxuICBzdG9yZS5fZGV2dG9vbEhvb2sgPSBkZXZ0b29sSG9vaztcblxuICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgZGV2dG9vbEhvb2sub24oJ3Z1ZXg6dHJhdmVsLXRvLXN0YXRlJywgZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgfSk7XG5cbiAgc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4Om11dGF0aW9uJywgbXV0YXRpb24sIHN0YXRlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBpdGVtIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogYnkgc2Vjb25kIGFyZ3VtZW50IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHJldHVybiB7Kn1cbiAqL1xuLyoqXG4gKiBEZWVwIGNvcHkgdGhlIGdpdmVuIG9iamVjdCBjb25zaWRlcmluZyBjaXJjdWxhciBzdHJ1Y3R1cmUuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhY2hlcyBhbGwgbmVzdGVkIG9iamVjdHMgYW5kIGl0cyBjb3BpZXMuXG4gKiBJZiBpdCBkZXRlY3RzIGNpcmN1bGFyIHN0cnVjdHVyZSwgdXNlIGNhY2hlZCBjb3B5IHRvIGF2b2lkIGluZmluaXRlIGxvb3AuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY2FjaGVcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuXG4vKipcbiAqIGZvckVhY2ggZm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBmb3JFYWNoVmFsdWUgKG9iaiwgZm4pIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtc2cpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKChcIlt2dWV4XSBcIiArIG1zZykpIH1cbn1cblxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZSAocmF3TW9kdWxlLCBydW50aW1lKSB7XG4gIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fcmF3TW9kdWxlID0gcmF3TW9kdWxlO1xuICB2YXIgcmF3U3RhdGUgPSByYXdNb2R1bGUuc3RhdGU7XG4gIHRoaXMuc3RhdGUgPSAodHlwZW9mIHJhd1N0YXRlID09PSAnZnVuY3Rpb24nID8gcmF3U3RhdGUoKSA6IHJhd1N0YXRlKSB8fCB7fTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgbmFtZXNwYWNlZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5uYW1lc3BhY2VkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhdGhpcy5fcmF3TW9kdWxlLm5hbWVzcGFjZWRcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZCAoa2V5LCBtb2R1bGUpIHtcbiAgdGhpcy5fY2hpbGRyZW5ba2V5XSA9IG1vZHVsZTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZCAoa2V5KSB7XG4gIGRlbGV0ZSB0aGlzLl9jaGlsZHJlbltrZXldO1xufTtcblxuTW9kdWxlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIGdldENoaWxkIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2tleV1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChyYXdNb2R1bGUpIHtcbiAgdGhpcy5fcmF3TW9kdWxlLm5hbWVzcGFjZWQgPSByYXdNb2R1bGUubmFtZXNwYWNlZDtcbiAgaWYgKHJhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgdGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMgPSByYXdNb2R1bGUuYWN0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMgPSByYXdNb2R1bGUubXV0YXRpb25zO1xuICB9XG4gIGlmIChyYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5nZXR0ZXJzID0gcmF3TW9kdWxlLmdldHRlcnM7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gZm9yRWFjaENoaWxkIChmbikge1xuICBmb3JFYWNoVmFsdWUodGhpcy5fY2hpbGRyZW4sIGZuKTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaEdldHRlciA9IGZ1bmN0aW9uIGZvckVhY2hHZXR0ZXIgKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycywgZm4pO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hBY3Rpb24gPSBmdW5jdGlvbiBmb3JFYWNoQWN0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoTXV0YXRpb24gPSBmdW5jdGlvbiBmb3JFYWNoTXV0YXRpb24gKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMsIGZuKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1vZHVsZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbnZhciBNb2R1bGVDb2xsZWN0aW9uID0gZnVuY3Rpb24gTW9kdWxlQ29sbGVjdGlvbiAocmF3Um9vdE1vZHVsZSkge1xuICAvLyByZWdpc3RlciByb290IG1vZHVsZSAoVnVleC5TdG9yZSBvcHRpb25zKVxuICB0aGlzLnJlZ2lzdGVyKFtdLCByYXdSb290TW9kdWxlLCBmYWxzZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChtb2R1bGUsIGtleSkge1xuICAgIHJldHVybiBtb2R1bGUuZ2V0Q2hpbGQoa2V5KVxuICB9LCB0aGlzLnJvb3QpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXROYW1lc3BhY2UgPSBmdW5jdGlvbiBnZXROYW1lc3BhY2UgKHBhdGgpIHtcbiAgdmFyIG1vZHVsZSA9IHRoaXMucm9vdDtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGtleSkge1xuICAgIG1vZHVsZSA9IG1vZHVsZS5nZXRDaGlsZChrZXkpO1xuICAgIHJldHVybiBuYW1lc3BhY2UgKyAobW9kdWxlLm5hbWVzcGFjZWQgPyBrZXkgKyAnLycgOiAnJylcbiAgfSwgJycpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUkMSAocmF3Um9vdE1vZHVsZSkge1xuICB1cGRhdGUoW10sIHRoaXMucm9vdCwgcmF3Um9vdE1vZHVsZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyIChwYXRoLCByYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICBpZiAoIHJ1bnRpbWUgPT09IHZvaWQgMCApIHJ1bnRpbWUgPSB0cnVlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UmF3TW9kdWxlKHBhdGgsIHJhd01vZHVsZSk7XG4gIH1cblxuICB2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZShyYXdNb2R1bGUsIHJ1bnRpbWUpO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnJvb3QgPSBuZXdNb2R1bGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBwYXJlbnQuYWRkQ2hpbGQocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBuZXdNb2R1bGUpO1xuICB9XG5cbiAgLy8gcmVnaXN0ZXIgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKHJhd01vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yRWFjaFZhbHVlKHJhd01vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3Q2hpbGRNb2R1bGUsIGtleSkge1xuICAgICAgdGhpcyQxLnJlZ2lzdGVyKHBhdGguY29uY2F0KGtleSksIHJhd0NoaWxkTW9kdWxlLCBydW50aW1lKTtcbiAgICB9KTtcbiAgfVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIgKHBhdGgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgdmFyIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgaWYgKCFwYXJlbnQuZ2V0Q2hpbGQoa2V5KS5ydW50aW1lKSB7IHJldHVybiB9XG5cbiAgcGFyZW50LnJlbW92ZUNoaWxkKGtleSk7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGUgKHBhdGgsIHRhcmdldE1vZHVsZSwgbmV3TW9kdWxlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UmF3TW9kdWxlKHBhdGgsIG5ld01vZHVsZSk7XG4gIH1cblxuICAvLyB1cGRhdGUgdGFyZ2V0IG1vZHVsZVxuICB0YXJnZXRNb2R1bGUudXBkYXRlKG5ld01vZHVsZSk7XG5cbiAgLy8gdXBkYXRlIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChuZXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvciAodmFyIGtleSBpbiBuZXdNb2R1bGUubW9kdWxlcykge1xuICAgICAgaWYgKCF0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiW3Z1ZXhdIHRyeWluZyB0byBhZGQgYSBuZXcgbW9kdWxlICdcIiArIGtleSArIFwiJyBvbiBob3QgcmVsb2FkaW5nLCBcIiArXG4gICAgICAgICAgICAnbWFudWFsIHJlbG9hZCBpcyBuZWVkZWQnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShcbiAgICAgICAgcGF0aC5jb25jYXQoa2V5KSxcbiAgICAgICAgdGFyZ2V0TW9kdWxlLmdldENoaWxkKGtleSksXG4gICAgICAgIG5ld01vZHVsZS5tb2R1bGVzW2tleV1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmdW5jdGlvbkFzc2VydCA9IHtcbiAgYXNzZXJ0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgZXhwZWN0ZWQ6ICdmdW5jdGlvbidcbn07XG5cbnZhciBvYmplY3RBc3NlcnQgPSB7XG4gIGFzc2VydDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUuaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyk7IH0sXG4gIGV4cGVjdGVkOiAnZnVuY3Rpb24gb3Igb2JqZWN0IHdpdGggXCJoYW5kbGVyXCIgZnVuY3Rpb24nXG59O1xuXG52YXIgYXNzZXJ0VHlwZXMgPSB7XG4gIGdldHRlcnM6IGZ1bmN0aW9uQXNzZXJ0LFxuICBtdXRhdGlvbnM6IGZ1bmN0aW9uQXNzZXJ0LFxuICBhY3Rpb25zOiBvYmplY3RBc3NlcnRcbn07XG5cbmZ1bmN0aW9uIGFzc2VydFJhd01vZHVsZSAocGF0aCwgcmF3TW9kdWxlKSB7XG4gIE9iamVjdC5rZXlzKGFzc2VydFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIXJhd01vZHVsZVtrZXldKSB7IHJldHVybiB9XG5cbiAgICB2YXIgYXNzZXJ0T3B0aW9ucyA9IGFzc2VydFR5cGVzW2tleV07XG5cbiAgICBmb3JFYWNoVmFsdWUocmF3TW9kdWxlW2tleV0sIGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBhc3NlcnRPcHRpb25zLmFzc2VydCh2YWx1ZSksXG4gICAgICAgIG1ha2VBc3NlcnRpb25NZXNzYWdlKHBhdGgsIGtleSwgdHlwZSwgdmFsdWUsIGFzc2VydE9wdGlvbnMuZXhwZWN0ZWQpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzc2VydGlvbk1lc3NhZ2UgKHBhdGgsIGtleSwgdHlwZSwgdmFsdWUsIGV4cGVjdGVkKSB7XG4gIHZhciBidWYgPSBrZXkgKyBcIiBzaG91bGQgYmUgXCIgKyBleHBlY3RlZCArIFwiIGJ1dCBcXFwiXCIgKyBrZXkgKyBcIi5cIiArIHR5cGUgKyBcIlxcXCJcIjtcbiAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgIGJ1ZiArPSBcIiBpbiBtb2R1bGUgXFxcIlwiICsgKHBhdGguam9pbignLicpKSArIFwiXFxcIlwiO1xuICB9XG4gIGJ1ZiArPSBcIiBpcyBcIiArIChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpICsgXCIuXCI7XG4gIHJldHVybiBidWZcbn1cblxudmFyIFZ1ZTsgLy8gYmluZCBvbiBpbnN0YWxsXG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAvLyBBdXRvIGluc3RhbGwgaWYgaXQgaXMgbm90IGRvbmUgeWV0IGFuZCBgd2luZG93YCBoYXMgYFZ1ZWAuXG4gIC8vIFRvIGFsbG93IHVzZXJzIHRvIGF2b2lkIGF1dG8taW5zdGFsbGF0aW9uIGluIHNvbWUgY2FzZXMsXG4gIC8vIHRoaXMgY29kZSBzaG91bGQgYmUgcGxhY2VkIGhlcmUuIFNlZSAjNzMxXG4gIGlmICghVnVlICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoVnVlLCBcIm11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLlwiKTtcbiAgICBhc3NlcnQodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnLCBcInZ1ZXggcmVxdWlyZXMgYSBQcm9taXNlIHBvbHlmaWxsIGluIHRoaXMgYnJvd3Nlci5cIik7XG4gICAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTdG9yZSwgXCJTdG9yZSBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3IuXCIpO1xuICB9XG5cbiAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7IGlmICggcGx1Z2lucyA9PT0gdm9pZCAwICkgcGx1Z2lucyA9IFtdO1xuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7IGlmICggc3RyaWN0ID09PSB2b2lkIDAgKSBzdHJpY3QgPSBmYWxzZTtcblxuICB2YXIgc3RhdGUgPSBvcHRpb25zLnN0YXRlOyBpZiAoIHN0YXRlID09PSB2b2lkIDAgKSBzdGF0ZSA9IHt9O1xuICBpZiAodHlwZW9mIHN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RhdGUgPSBzdGF0ZSgpIHx8IHt9O1xuICB9XG5cbiAgLy8gc3RvcmUgaW50ZXJuYWwgc3RhdGVcbiAgdGhpcy5fY29tbWl0dGluZyA9IGZhbHNlO1xuICB0aGlzLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fYWN0aW9uU3Vic2NyaWJlcnMgPSBbXTtcbiAgdGhpcy5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9tb2R1bGVzID0gbmV3IE1vZHVsZUNvbGxlY3Rpb24ob3B0aW9ucyk7XG4gIHRoaXMuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl93YXRjaGVyVk0gPSBuZXcgVnVlKCk7XG5cbiAgLy8gYmluZCBjb21taXQgYW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgdmFyIHN0b3JlID0gdGhpcztcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcbiAgdmFyIGNvbW1pdCA9IHJlZi5jb21taXQ7XG4gIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiBib3VuZERpc3BhdGNoICh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoLmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQpXG4gIH07XG4gIHRoaXMuY29tbWl0ID0gZnVuY3Rpb24gYm91bmRDb21taXQgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tbWl0LmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpXG4gIH07XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdCk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgdm0sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcmVhY3Rpdml0eVxuICAvLyAoYWxzbyByZWdpc3RlcnMgX3dyYXBwZWRHZXR0ZXJzIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMpXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCBzdGF0ZSk7XG5cbiAgLy8gYXBwbHkgcGx1Z2luc1xuICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikgeyByZXR1cm4gcGx1Z2luKHRoaXMkMSk7IH0pO1xuXG4gIGlmIChWdWUuY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbFBsdWdpbih0aGlzKTtcbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgc3RhdGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnN0YXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ZtLl9kYXRhLiQkc3RhdGVcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5zdGF0ZS5zZXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChmYWxzZSwgXCJVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS5cIik7XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiBjb21taXQgKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgY29tbWl0XG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcbiAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuXG4gIHZhciBtdXRhdGlvbiA9IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICB2YXIgZW50cnkgPSB0aGlzLl9tdXRhdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiBjb21taXRJdGVyYXRvciAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcihwYXlsb2FkKTtcbiAgICB9KTtcbiAgfSk7XG4gIHRoaXMuX3N1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViKG11dGF0aW9uLCB0aGlzJDEuc3RhdGUpOyB9KTtcblxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zaWxlbnRcbiAgKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbdnVleF0gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlICsgXCIuIFNpbGVudCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gXCIgK1xuICAgICAgJ1VzZSB0aGUgZmlsdGVyIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHZ1ZS1kZXZ0b29scydcbiAgICApO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAoX3R5cGUsIF9wYXlsb2FkKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGRpc3BhdGNoXG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCk7XG4gICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgcGF5bG9hZCA9IHJlZi5wYXlsb2FkO1xuXG4gIHZhciBhY3Rpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fYWN0aW9uc1t0eXBlXTtcbiAgaWYgKCFlbnRyeSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLl9hY3Rpb25TdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1YihhY3Rpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuXG4gIHJldHVybiBlbnRyeS5sZW5ndGggPiAxXG4gICAgPyBQcm9taXNlLmFsbChlbnRyeS5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGhhbmRsZXIocGF5bG9hZCk7IH0pKVxuICAgIDogZW50cnlbMF0ocGF5bG9hZClcbn07XG5cblN0b3JlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUgKGZuKSB7XG4gIHJldHVybiBnZW5lcmljU3Vic2NyaWJlKGZuLCB0aGlzLl9zdWJzY3JpYmVycylcbn07XG5cblN0b3JlLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpb24gPSBmdW5jdGlvbiBzdWJzY3JpYmVBY3Rpb24gKGZuKSB7XG4gIHJldHVybiBnZW5lcmljU3Vic2NyaWJlKGZuLCB0aGlzLl9hY3Rpb25TdWJzY3JpYmVycylcbn07XG5cblN0b3JlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIHdhdGNoIChnZXR0ZXIsIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIGdldHRlciA9PT0gJ2Z1bmN0aW9uJywgXCJzdG9yZS53YXRjaCBvbmx5IGFjY2VwdHMgYSBmdW5jdGlvbi5cIik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3dhdGNoZXJWTS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0dGVyKHRoaXMkMS5zdGF0ZSwgdGhpcyQxLmdldHRlcnMpOyB9LCBjYiwgb3B0aW9ucylcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiByZXBsYWNlU3RhdGUgKHN0YXRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLl92bS5fZGF0YS4kJHN0YXRlID0gc3RhdGU7XG4gIH0pO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnJlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGUgKHBhdGgsIHJhd01vZHVsZSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gICAgYXNzZXJ0KHBhdGgubGVuZ3RoID4gMCwgJ2Nhbm5vdCByZWdpc3RlciB0aGUgcm9vdCBtb2R1bGUgYnkgdXNpbmcgcmVnaXN0ZXJNb2R1bGUuJyk7XG4gIH1cblxuICB0aGlzLl9tb2R1bGVzLnJlZ2lzdGVyKHBhdGgsIHJhd01vZHVsZSk7XG4gIGluc3RhbGxNb2R1bGUodGhpcywgdGhpcy5zdGF0ZSwgcGF0aCwgdGhpcy5fbW9kdWxlcy5nZXQocGF0aCksIG9wdGlvbnMucHJlc2VydmVTdGF0ZSk7XG4gIC8vIHJlc2V0IHN0b3JlIHRvIHVwZGF0ZSBnZXR0ZXJzLi4uXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCB0aGlzLnN0YXRlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS51bnJlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24gdW5yZWdpc3Rlck1vZHVsZSAocGF0aCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gIH1cblxuICB0aGlzLl9tb2R1bGVzLnVucmVnaXN0ZXIocGF0aCk7XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHRoaXMkMS5zdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIFZ1ZS5kZWxldGUocGFyZW50U3RhdGUsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XG4gIH0pO1xuICByZXNldFN0b3JlKHRoaXMpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmhvdFVwZGF0ZSA9IGZ1bmN0aW9uIGhvdFVwZGF0ZSAobmV3T3B0aW9ucykge1xuICB0aGlzLl9tb2R1bGVzLnVwZGF0ZShuZXdPcHRpb25zKTtcbiAgcmVzZXRTdG9yZSh0aGlzLCB0cnVlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5fd2l0aENvbW1pdCA9IGZ1bmN0aW9uIF93aXRoQ29tbWl0IChmbikge1xuICB2YXIgY29tbWl0dGluZyA9IHRoaXMuX2NvbW1pdHRpbmc7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSB0cnVlO1xuICBmbigpO1xuICB0aGlzLl9jb21taXR0aW5nID0gY29tbWl0dGluZztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdG9yZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiBnZW5lcmljU3Vic2NyaWJlIChmbiwgc3Vicykge1xuICBpZiAoc3Vicy5pbmRleE9mKGZuKSA8IDApIHtcbiAgICBzdWJzLnB1c2goZm4pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBzdWJzLmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHN1YnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldFN0b3JlIChzdG9yZSwgaG90KSB7XG4gIHN0b3JlLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHN0YXRlID0gc3RvcmUuc3RhdGU7XG4gIC8vIGluaXQgYWxsIG1vZHVsZXNcbiAgaW5zdGFsbE1vZHVsZShzdG9yZSwgc3RhdGUsIFtdLCBzdG9yZS5fbW9kdWxlcy5yb290LCB0cnVlKTtcbiAgLy8gcmVzZXQgdm1cbiAgcmVzZXRTdG9yZVZNKHN0b3JlLCBzdGF0ZSwgaG90KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZVZNIChzdG9yZSwgc3RhdGUsIGhvdCkge1xuICB2YXIgb2xkVm0gPSBzdG9yZS5fdm07XG5cbiAgLy8gYmluZCBzdG9yZSBwdWJsaWMgZ2V0dGVyc1xuICBzdG9yZS5nZXR0ZXJzID0ge307XG4gIHZhciB3cmFwcGVkR2V0dGVycyA9IHN0b3JlLl93cmFwcGVkR2V0dGVycztcbiAgdmFyIGNvbXB1dGVkID0ge307XG4gIGZvckVhY2hWYWx1ZSh3cmFwcGVkR2V0dGVycywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAvLyB1c2UgY29tcHV0ZWQgdG8gbGV2ZXJhZ2UgaXRzIGxhenktY2FjaGluZyBtZWNoYW5pc21cbiAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4oc3RvcmUpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yZS5nZXR0ZXJzLCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuX3ZtW2tleV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlIC8vIGZvciBsb2NhbCBnZXR0ZXJzXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHVzZSBhIFZ1ZSBpbnN0YW5jZSB0byBzdG9yZSB0aGUgc3RhdGUgdHJlZVxuICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBqdXN0IGluIGNhc2UgdGhlIHVzZXIgaGFzIGFkZGVkXG4gIC8vIHNvbWUgZnVua3kgZ2xvYmFsIG1peGluc1xuICB2YXIgc2lsZW50ID0gVnVlLmNvbmZpZy5zaWxlbnQ7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gdHJ1ZTtcbiAgc3RvcmUuX3ZtID0gbmV3IFZ1ZSh7XG4gICAgZGF0YToge1xuICAgICAgJCRzdGF0ZTogc3RhdGVcbiAgICB9LFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZFxuICB9KTtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSBzaWxlbnQ7XG5cbiAgLy8gZW5hYmxlIHN0cmljdCBtb2RlIGZvciBuZXcgdm1cbiAgaWYgKHN0b3JlLnN0cmljdCkge1xuICAgIGVuYWJsZVN0cmljdE1vZGUoc3RvcmUpO1xuICB9XG5cbiAgaWYgKG9sZFZtKSB7XG4gICAgaWYgKGhvdCkge1xuICAgICAgLy8gZGlzcGF0Y2ggY2hhbmdlcyBpbiBhbGwgc3Vic2NyaWJlZCB3YXRjaGVyc1xuICAgICAgLy8gdG8gZm9yY2UgZ2V0dGVyIHJlLWV2YWx1YXRpb24gZm9yIGhvdCByZWxvYWRpbmcuXG4gICAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9sZFZtLl9kYXRhLiQkc3RhdGUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFZ1ZS5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiBvbGRWbS4kZGVzdHJveSgpOyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsTW9kdWxlIChzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLCBtb2R1bGUsIGhvdCkge1xuICB2YXIgaXNSb290ID0gIXBhdGgubGVuZ3RoO1xuICB2YXIgbmFtZXNwYWNlID0gc3RvcmUuX21vZHVsZXMuZ2V0TmFtZXNwYWNlKHBhdGgpO1xuXG4gIC8vIHJlZ2lzdGVyIGluIG5hbWVzcGFjZSBtYXBcbiAgaWYgKG1vZHVsZS5uYW1lc3BhY2VkKSB7XG4gICAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSA9IG1vZHVsZTtcbiAgfVxuXG4gIC8vIHNldCBzdGF0ZVxuICBpZiAoIWlzUm9vdCAmJiAhaG90KSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUocm9vdFN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgdmFyIG1vZHVsZU5hbWUgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgVnVlLnNldChwYXJlbnRTdGF0ZSwgbW9kdWxlTmFtZSwgbW9kdWxlLnN0YXRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsb2NhbCA9IG1vZHVsZS5jb250ZXh0ID0gbWFrZUxvY2FsQ29udGV4dChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKTtcblxuICBtb2R1bGUuZm9yRWFjaE11dGF0aW9uKGZ1bmN0aW9uIChtdXRhdGlvbiwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyTXV0YXRpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBtdXRhdGlvbiwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBrZXkpIHtcbiAgICB2YXIgdHlwZSA9IGFjdGlvbi5yb290ID8ga2V5IDogbmFtZXNwYWNlICsga2V5O1xuICAgIHZhciBoYW5kbGVyID0gYWN0aW9uLmhhbmRsZXIgfHwgYWN0aW9uO1xuICAgIHJlZ2lzdGVyQWN0aW9uKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoR2V0dGVyKGZ1bmN0aW9uIChnZXR0ZXIsIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleTtcbiAgICByZWdpc3RlckdldHRlcihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIGdldHRlciwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCwga2V5KSB7XG4gICAgaW5zdGFsbE1vZHVsZShzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLmNvbmNhdChrZXkpLCBjaGlsZCwgaG90KTtcbiAgfSk7XG59XG5cbi8qKlxuICogbWFrZSBsb2NhbGl6ZWQgZGlzcGF0Y2gsIGNvbW1pdCwgZ2V0dGVycyBhbmQgc3RhdGVcbiAqIGlmIHRoZXJlIGlzIG5vIG5hbWVzcGFjZSwganVzdCB1c2Ugcm9vdCBvbmVzXG4gKi9cbmZ1bmN0aW9uIG1ha2VMb2NhbENvbnRleHQgKHN0b3JlLCBuYW1lc3BhY2UsIHBhdGgpIHtcbiAgdmFyIG5vTmFtZXNwYWNlID0gbmFtZXNwYWNlID09PSAnJztcblxuICB2YXIgbG9jYWwgPSB7XG4gICAgZGlzcGF0Y2g6IG5vTmFtZXNwYWNlID8gc3RvcmUuZGlzcGF0Y2ggOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0b3JlLl9hY3Rpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBhY3Rpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKHR5cGUsIHBheWxvYWQpXG4gICAgfSxcblxuICAgIGNvbW1pdDogbm9OYW1lc3BhY2UgPyBzdG9yZS5jb21taXQgOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0b3JlLl9tdXRhdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGxvY2FsIG11dGF0aW9uIHR5cGU6IFwiICsgKGFyZ3MudHlwZSkgKyBcIiwgZ2xvYmFsIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3JlLmNvbW1pdCh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZ2V0dGVycyBhbmQgc3RhdGUgb2JqZWN0IG11c3QgYmUgZ290dGVuIGxhemlseVxuICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBjaGFuZ2VkIGJ5IHZtIHVwZGF0ZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsb2NhbCwge1xuICAgIGdldHRlcnM6IHtcbiAgICAgIGdldDogbm9OYW1lc3BhY2VcbiAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5nZXR0ZXJzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZUxvY2FsR2V0dGVycyhzdG9yZSwgbmFtZXNwYWNlKTsgfVxuICAgIH0sXG4gICAgc3RhdGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0TmVzdGVkU3RhdGUoc3RvcmUuc3RhdGUsIHBhdGgpOyB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbG9jYWxcbn1cblxuZnVuY3Rpb24gbWFrZUxvY2FsR2V0dGVycyAoc3RvcmUsIG5hbWVzcGFjZSkge1xuICB2YXIgZ2V0dGVyc1Byb3h5ID0ge307XG5cbiAgdmFyIHNwbGl0UG9zID0gbmFtZXNwYWNlLmxlbmd0aDtcbiAgT2JqZWN0LmtleXMoc3RvcmUuZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vIHNraXAgaWYgdGhlIHRhcmdldCBnZXR0ZXIgaXMgbm90IG1hdGNoIHRoaXMgbmFtZXNwYWNlXG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgc3BsaXRQb3MpICE9PSBuYW1lc3BhY2UpIHsgcmV0dXJuIH1cblxuICAgIC8vIGV4dHJhY3QgbG9jYWwgZ2V0dGVyIHR5cGVcbiAgICB2YXIgbG9jYWxUeXBlID0gdHlwZS5zbGljZShzcGxpdFBvcyk7XG5cbiAgICAvLyBBZGQgYSBwb3J0IHRvIHRoZSBnZXR0ZXJzIHByb3h5LlxuICAgIC8vIERlZmluZSBhcyBnZXR0ZXIgcHJvcGVydHkgYmVjYXVzZVxuICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV2YWx1YXRlIHRoZSBnZXR0ZXJzIGluIHRoaXMgdGltZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0dGVyc1Byb3h5LCBsb2NhbFR5cGUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyc1t0eXBlXTsgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGdldHRlcnNQcm94eVxufVxuXG5mdW5jdGlvbiByZWdpc3Rlck11dGF0aW9uIChzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpIHtcbiAgdmFyIGVudHJ5ID0gc3RvcmUuX211dGF0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX211dGF0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkTXV0YXRpb25IYW5kbGVyIChwYXlsb2FkKSB7XG4gICAgaGFuZGxlci5jYWxsKHN0b3JlLCBsb2NhbC5zdGF0ZSwgcGF5bG9hZCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9hY3Rpb25zW3R5cGVdIHx8IChzdG9yZS5fYWN0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkQWN0aW9uSGFuZGxlciAocGF5bG9hZCwgY2IpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5jYWxsKHN0b3JlLCB7XG4gICAgICBkaXNwYXRjaDogbG9jYWwuZGlzcGF0Y2gsXG4gICAgICBjb21taXQ6IGxvY2FsLmNvbW1pdCxcbiAgICAgIGdldHRlcnM6IGxvY2FsLmdldHRlcnMsXG4gICAgICBzdGF0ZTogbG9jYWwuc3RhdGUsXG4gICAgICByb290R2V0dGVyczogc3RvcmUuZ2V0dGVycyxcbiAgICAgIHJvb3RTdGF0ZTogc3RvcmUuc3RhdGVcbiAgICB9LCBwYXlsb2FkLCBjYik7XG4gICAgaWYgKCFpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzID0gUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG4gICAgfVxuICAgIGlmIChzdG9yZS5fZGV2dG9vbEhvb2spIHtcbiAgICAgIHJldHVybiByZXMuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzdG9yZS5fZGV2dG9vbEhvb2suZW1pdCgndnVleDplcnJvcicsIGVycik7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyR2V0dGVyIChzdG9yZSwgdHlwZSwgcmF3R2V0dGVyLCBsb2NhbCkge1xuICBpZiAoc3RvcmUuX3dyYXBwZWRHZXR0ZXJzW3R5cGVdKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBnZXR0ZXIga2V5OiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgc3RvcmUuX3dyYXBwZWRHZXR0ZXJzW3R5cGVdID0gZnVuY3Rpb24gd3JhcHBlZEdldHRlciAoc3RvcmUpIHtcbiAgICByZXR1cm4gcmF3R2V0dGVyKFxuICAgICAgbG9jYWwuc3RhdGUsIC8vIGxvY2FsIHN0YXRlXG4gICAgICBsb2NhbC5nZXR0ZXJzLCAvLyBsb2NhbCBnZXR0ZXJzXG4gICAgICBzdG9yZS5zdGF0ZSwgLy8gcm9vdCBzdGF0ZVxuICAgICAgc3RvcmUuZ2V0dGVycyAvLyByb290IGdldHRlcnNcbiAgICApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuYWJsZVN0cmljdE1vZGUgKHN0b3JlKSB7XG4gIHN0b3JlLl92bS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YS4kJHN0YXRlIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KHN0b3JlLl9jb21taXR0aW5nLCBcIkRvIG5vdCBtdXRhdGUgdnVleCBzdG9yZSBzdGF0ZSBvdXRzaWRlIG11dGF0aW9uIGhhbmRsZXJzLlwiKTtcbiAgICB9XG4gIH0sIHsgZGVlcDogdHJ1ZSwgc3luYzogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmVzdGVkU3RhdGUgKHN0YXRlLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aFxuICAgID8gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCBrZXkpIHsgcmV0dXJuIHN0YXRlW2tleV07IH0sIHN0YXRlKVxuICAgIDogc3RhdGVcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgKFwiRXhwZWN0cyBzdHJpbmcgYXMgdGhlIHR5cGUsIGJ1dCBmb3VuZCBcIiArICh0eXBlb2YgdHlwZSkgKyBcIi5cIikpO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCwgb3B0aW9uczogb3B0aW9ucyB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGwgKF9WdWUpIHtcbiAgaWYgKFZ1ZSAmJiBfVnVlID09PSBWdWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1t2dWV4XSBhbHJlYWR5IGluc3RhbGxlZC4gVnVlLnVzZShWdWV4KSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBWdWUgPSBfVnVlO1xuICBhcHBseU1peGluKFZ1ZSk7XG59XG5cbnZhciBtYXBTdGF0ZSA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBzdGF0ZXMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoc3RhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkU3RhdGUgKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy4kc3RvcmUuc3RhdGU7XG4gICAgICB2YXIgZ2V0dGVycyA9IHRoaXMuJHN0b3JlLmdldHRlcnM7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcFN0YXRlJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IG1vZHVsZS5jb250ZXh0LnN0YXRlO1xuICAgICAgICBnZXR0ZXJzID0gbW9kdWxlLmNvbnRleHQuZ2V0dGVycztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdmFsLmNhbGwodGhpcywgc3RhdGUsIGdldHRlcnMpXG4gICAgICAgIDogc3RhdGVbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwTXV0YXRpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIG11dGF0aW9ucykge1xuICB2YXIgcmVzID0ge307XG4gIG5vcm1hbGl6ZU1hcChtdXRhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRNdXRhdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdmFyIGNvbW1pdCA9IHRoaXMuJHN0b3JlLmNvbW1pdDtcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwTXV0YXRpb25zJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb21taXQgPSBtb2R1bGUuY29udGV4dC5jb21taXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5hcHBseSh0aGlzLCBbY29tbWl0XS5jb25jYXQoYXJncykpXG4gICAgICAgIDogY29tbWl0LmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwR2V0dGVycyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBnZXR0ZXJzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkR2V0dGVyICgpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwR2V0dGVycycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhKHZhbCBpbiB0aGlzLiRzdG9yZS5nZXR0ZXJzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGdldHRlcjogXCIgKyB2YWwpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1t2YWxdXG4gICAgfTtcbiAgICAvLyBtYXJrIHZ1ZXggZ2V0dGVyIGZvciBkZXZ0b29sc1xuICAgIHJlc1trZXldLnZ1ZXggPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbnZhciBtYXBBY3Rpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGFjdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZEFjdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdmFyIGRpc3BhdGNoID0gdGhpcy4kc3RvcmUuZGlzcGF0Y2g7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEFjdGlvbnMnLCBuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoID0gbW9kdWxlLmNvbnRleHQuZGlzcGF0Y2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5hcHBseSh0aGlzLCBbZGlzcGF0Y2hdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgOiBkaXNwYXRjaC5hcHBseSh0aGlzLiRzdG9yZSwgW3ZhbF0uY29uY2F0KGFyZ3MpKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSkgeyByZXR1cm4gKHtcbiAgbWFwU3RhdGU6IG1hcFN0YXRlLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwR2V0dGVyczogbWFwR2V0dGVycy5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwQWN0aW9uczogbWFwQWN0aW9ucy5iaW5kKG51bGwsIG5hbWVzcGFjZSlcbn0pOyB9O1xuXG5mdW5jdGlvbiBub3JtYWxpemVNYXAgKG1hcCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXApXG4gICAgPyBtYXAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IGtleSB9KTsgfSlcbiAgICA6IE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IG1hcFtrZXldIH0pOyB9KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lc3BhY2UgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZXNwYWNlLCBtYXApIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcCA9IG5hbWVzcGFjZTtcbiAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGZuKG5hbWVzcGFjZSwgbWFwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZUJ5TmFtZXNwYWNlIChzdG9yZSwgaGVscGVyLCBuYW1lc3BhY2UpIHtcbiAgdmFyIG1vZHVsZSA9IHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtb2R1bGUpIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSBtb2R1bGUgbmFtZXNwYWNlIG5vdCBmb3VuZCBpbiBcIiArIGhlbHBlciArIFwiKCk6IFwiICsgbmFtZXNwYWNlKSk7XG4gIH1cbiAgcmV0dXJuIG1vZHVsZVxufVxuXG52YXIgaW5kZXhfZXNtID0ge1xuICBTdG9yZTogU3RvcmUsXG4gIGluc3RhbGw6IGluc3RhbGwsXG4gIHZlcnNpb246ICczLjAuMCcsXG4gIG1hcFN0YXRlOiBtYXBTdGF0ZSxcbiAgbWFwTXV0YXRpb25zOiBtYXBNdXRhdGlvbnMsXG4gIG1hcEdldHRlcnM6IG1hcEdldHRlcnMsXG4gIG1hcEFjdGlvbnM6IG1hcEFjdGlvbnMsXG4gIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzOiBjcmVhdGVOYW1lc3BhY2VkSGVscGVyc1xufTtcblxuZXhwb3J0IHsgU3RvcmUsIGluc3RhbGwsIG1hcFN0YXRlLCBtYXBNdXRhdGlvbnMsIG1hcEdldHRlcnMsIG1hcEFjdGlvbnMsIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzIH07XG5leHBvcnQgZGVmYXVsdCBpbmRleF9lc207XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVleC9kaXN0L3Z1ZXguZXNtLmpzIiwiLyohXG4gKiBWdWUuanMgdjIuNS4yXG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlIGUuZy4gW29iamVjdCBPYmplY3RdXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cblxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJ1xuXTtcblxuLyogICovXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bSB8fCB7fTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZnVuY3Rpb25hbE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZnVuY3Rpb25hbFNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlLCBkZWVwKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIGlmIChkZWVwICYmIHZub2RlLmNoaWxkcmVuKSB7XG4gICAgY2xvbmVkLmNoaWxkcmVuID0gY2xvbmVWTm9kZXModm5vZGUuY2hpbGRyZW4pO1xuICB9XG4gIHJldHVybiBjbG9uZWRcbn1cblxuZnVuY3Rpb24gY2xvbmVWTm9kZXMgKHZub2RlcywgZGVlcCkge1xuICB2YXIgbGVuID0gdm5vZGVzLmxlbmd0aDtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzW2ldID0gY2xvbmVWTm9kZSh2bm9kZXNbaV0sIGRlZXApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbi5jYWxsKHRoaXMsIHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xuICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGluamVjdCkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpICtcbiAgICAgIFwiLCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHZtKSB7XG4gICAgdmFyIGN1ciA9IHZtO1xuICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgIGlmIChob29rcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNZXNzYWdlQ2hhbm5lbCAqL1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBib3RoIG1pY3JvIGFuZCBtYWNybyB0YXNrcy5cbi8vIEluIDwgMi40IHdlIHVzZWQgbWljcm8gdGFza3MgZXZlcnl3aGVyZSwgYnV0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvcyB3aGVyZVxuLy8gbWljcm8gdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlcyBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCkgb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lXG4vLyBldmVudCAoIzY1NjYpLiBIb3dldmVyLCB1c2luZyBtYWNybyB0YXNrcyBldmVyeXdoZXJlIGFsc28gaGFzIHN1YnRsZSBwcm9ibGVtc1xuLy8gd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50IChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gSGVyZSB3ZSB1c2UgbWljcm8gdGFzayBieSBkZWZhdWx0LCBidXQgZXhwb3NlIGEgd2F5IHRvIGZvcmNlIG1hY3JvIHRhc2sgd2hlblxuLy8gbmVlZGVkIChlLmcuIGluIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIGJ5IHYtb24pLlxudmFyIG1pY3JvVGltZXJGdW5jO1xudmFyIG1hY3JvVGltZXJGdW5jO1xudmFyIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuXG4vLyBEZXRlcm1pbmUgKG1hY3JvKSBUYXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLy8gVGVjaG5pY2FsbHkgc2V0SW1tZWRpYXRlIHNob3VsZCBiZSB0aGUgaWRlYWwgY2hvaWNlLCBidXQgaXQncyBvbmx5IGF2YWlsYWJsZVxuLy8gaW4gSUUuIFRoZSBvbmx5IHBvbHlmaWxsIHRoYXQgY29uc2lzdGVudGx5IHF1ZXVlcyB0aGUgY2FsbGJhY2sgYWZ0ZXIgYWxsIERPTVxuLy8gZXZlbnRzIHRyaWdnZXJlZCBpbiB0aGUgc2FtZSBsb29wIGlzIGJ5IHVzaW5nIE1lc3NhZ2VDaGFubmVsLlxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTWVzc2FnZUNoYW5uZWwpIHx8XG4gIC8vIFBoYW50b21KU1xuICBNZXNzYWdlQ2hhbm5lbC50b1N0cmluZygpID09PSAnW29iamVjdCBNZXNzYWdlQ2hhbm5lbENvbnN0cnVjdG9yXSdcbikpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoQ2FsbGJhY2tzO1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwb3J0LnBvc3RNZXNzYWdlKDEpO1xuICB9O1xufSBlbHNlIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbi8vIERldGVybWluZSBNaWNyb1Rhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIG1pY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gZmFsbGJhY2sgdG8gbWFjcm9cbiAgbWljcm9UaW1lckZ1bmMgPSBtYWNyb1RpbWVyRnVuYztcbn1cblxuLyoqXG4gKiBXcmFwIGEgZnVuY3Rpb24gc28gdGhhdCBpZiBhbnkgY29kZSBpbnNpZGUgdHJpZ2dlcnMgc3RhdGUgY2hhbmdlLFxuICogdGhlIGNoYW5nZXMgYXJlIHF1ZXVlZCB1c2luZyBhIFRhc2sgaW5zdGVhZCBvZiBhIE1pY3JvVGFzay5cbiAqL1xuZnVuY3Rpb24gd2l0aE1hY3JvVGFzayAoZm4pIHtcbiAgcmV0dXJuIGZuLl93aXRoVGFzayB8fCAoZm4uX3dpdGhUYXNrID0gZnVuY3Rpb24gKCkge1xuICAgIHVzZU1hY3JvVGFzayA9IHRydWU7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgdXNlTWFjcm9UYXNrID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc1xuICB9KVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGN0eCkge1xuICB2YXIgX3Jlc29sdmU7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZShjdHgpO1xuICAgIH1cbiAgfSk7XG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIGlmICh1c2VNYWNyb1Rhc2spIHtcbiAgICAgIG1hY3JvVGltZXJGdW5jKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pY3JvVGltZXJGdW5jKCk7XG4gICAgfVxuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3RJbmRleCwgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKTtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgKGNbMF0pLnRleHQpO1xuICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZnVuY3Rpb25hbENvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGNoaWxkLmRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcbiAgaWYgKCFkZWZhdWx0U2xvdC5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50IHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gKHBhcmVudFZub2RlLmRhdGEgJiYgcGFyZW50Vm5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogdXNlckRlZjtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGtleU9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGtleU9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluamVjdCwga2V5KS5lbnVtZXJhYmxlXG4gICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIHByb3ZpZGVLZXkgaW4gc291cmNlLl9wcm92aWRlZCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhcyxcbiAgZXZlbnRLZXlOYW1lXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoa2V5Q29kZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gICAgfVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgLy8gc3RhdGljIHRyZWVzIGNhbiBiZSByZW5kZXJlZCBvbmNlIGFuZCBjYWNoZWQgb24gdGhlIGNvbnRydWN0b3Igb3B0aW9uc1xuICAvLyBzbyBldmVyeSBpbnN0YW5jZSBzaGFyZXMgdGhlIHNhbWUgY2FjaGVkIHRyZWVzXG4gIHZhciByZW5kZXJGbnMgPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgdmFyIGNhY2hlZCA9IHJlbmRlckZucy5jYWNoZWQgfHwgKHJlbmRlckZucy5jYWNoZWQgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHJlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSwgbnVsbCwgdGhpcyk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xuXG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBkYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgdm5vZGUuZnVuY3Rpb25hbFNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pOyB9O1xuICB9XG59XG5cbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHRWbSxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cblxuICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChcbiAgICBkYXRhLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHRWbSxcbiAgICBDdG9yXG4gICk7XG5cbiAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dFZtO1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlQ29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoaXNVbmRlZihjaGlsZC5ucykgfHwgaXNUcnVlKGZvcmNlKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgLy8gaWYgdGhlIHBhcmVudCBkaWRuJ3QgdXBkYXRlLCB0aGUgc2xvdCBub2RlcyB3aWxsIGJlIHRoZSBvbmVzIGZyb21cbiAgICAgIC8vIGxhc3QgcmVuZGVyLiBUaGV5IG5lZWQgdG8gYmUgY2xvbmVkIHRvIGVuc3VyZSBcImZyZXNobmVzc1wiIGZvciB0aGlzIHJlbmRlci5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdmFyIHNsb3QgPSB2bS4kc2xvdHNba2V5XTtcbiAgICAgICAgaWYgKHNsb3QuX3JlbmRlcmVkKSB7XG4gICAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2RlcyhzbG90LCB0cnVlIC8qIGRlZXAgKi8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlJDMgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMylcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgY2FjaGVkJCQxICE9PSBjdXJyZW50KSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGUsIGtleSwgdGhpcyQxLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZi5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuNS4yJztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cblxuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpblByZSA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGluUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpblByZSAmJlxuICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICEoXG4gICAgICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHRhZylcbiAgICAgICAgICAgICAgICA6IGlnbm9yZSA9PT0gdGFnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkgJiZcbiAgICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBpblByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZnVuY3Rpb25hbFNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF2bm9kZVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhYmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFiYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRTkgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgID8gJ3RydWUnXG4gICAgICAgIDoga2V5O1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbi8qICAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cblxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5cbi8qICAqL1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChoYW5kbGVyLCBldmVudCwgY2FwdHVyZSkge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGhhbmRsZXIgPSB3aXRoTWFjcm9UYXNrKGhhbmRsZXIpO1xuICBpZiAob25jZSQkMSkgeyBoYW5kbGVyID0gY3JlYXRlT25jZUhhbmRsZXIoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpOyB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlci5fd2l0aFRhc2sgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLm51bWJlcikge1xuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgfVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMudHJpbSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZik7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZilcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogbW9kZWwkMSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5WdWUkMy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuZXhwb3J0IGRlZmF1bHQgVnVlJDM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xuKi9cblxudmFyIGhhc0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5pZiAodHlwZW9mIERFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBERUJVRykge1xuICBpZiAoIWhhc0RvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2dWUtc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuICcgK1xuICAgIFwiVXNlIHsgdGFyZ2V0OiAnbm9kZScgfSBpbiB5b3VyIFdlYnBhY2sgY29uZmlnIHRvIGluZGljYXRlIGEgc2VydmVyLXJlbmRlcmluZyBlbnZpcm9ubWVudC5cIlxuICApIH1cbn1cblxudmFyIGxpc3RUb1N0eWxlcyA9IHJlcXVpcmUoJy4vbGlzdFRvU3R5bGVzJylcblxuLypcbnR5cGUgU3R5bGVPYmplY3QgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XG59XG5cbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xuICBjc3M6IHN0cmluZztcbiAgbWVkaWE6IHN0cmluZztcbiAgc291cmNlTWFwOiA/c3RyaW5nXG59XG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7LypcbiAgW2lkOiBudW1iZXJdOiB7XG4gICAgaWQ6IG51bWJlcixcbiAgICByZWZzOiBudW1iZXIsXG4gICAgcGFydHM6IEFycmF5PChvYmo/OiBTdHlsZU9iamVjdFBhcnQpID0+IHZvaWQ+XG4gIH1cbiovfVxuXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXG52YXIgc2luZ2xldG9uRWxlbWVudCA9IG51bGxcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMFxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxudmFyIGlzT2xkSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKCkge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLXZ1ZS1zc3ItaWR+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUnXG5pbXBvcnQgZW5naW5lIGZyb20gJy4vZW5naW5lJ1xuaW1wb3J0IE1haW4gZnJvbSAnLi9jb21wb25lbnRzL01haW4udnVlJ1xuXG5jb25zdCBhcHBsaWNhdGlvbiA9IG5ldyBWdWUoe1xuICBlbDogJyNtYWluJyxcbiAgc3RvcmUsXG4gIHJlbmRlcjogaGFuZGxlciA9PiBoYW5kbGVyKE1haW4pXG59KVxuXG5lbmdpbmUuc3RhcnQoc3RvcmUpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXguanMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBWdWV4IGZyb20gJ3Z1ZXgnXG5cbmltcG9ydCBzdGF0ZSBmcm9tICcuL3N0YXRlJ1xuaW1wb3J0IG11dGF0aW9ucyBmcm9tICcuL211dGF0aW9ucydcblxuVnVlLnVzZShWdWV4KVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgVnVleC5TdG9yZSh7c3RhdGUsIG11dGF0aW9uc30pXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RvcmUvaW5kZXguanMiLCJjb25zdCBjbGlwID0ge1xuICBjb3VudDogMCxcbiAgc3RvY2s6IDAsXG4gIHByaWNlOiAwLjI1XG59XG5cbmNvbnN0IHZhcmlhdGlvbiA9IHtcbiAgZGVtYW5kOiAwLjAxLFxuICBjbGlwUHJpY2U6IDAuMDEsXG4gIHdpcmVQcmljZTogMC4yXG59XG5cbmNvbnN0IHdpcmUgPSB7XG4gIHN0b2NrOiAxMDAwLFxuICBiYXRjaFNpemU6IDEwMDAsXG4gIGJhc2VQcmljZTogMTRcbn1cblxuY29uc3Qgc3RhdHMgPSB7XG4gIGZ1bmRzOiAwLFxuICBkZW1hbmQ6IDAuM1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtjbGlwLCB2YXJpYXRpb24sIHdpcmUsIHN0YXRzfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3N0b3JlL3N0YXRlLmpzIiwiY29uc3QgcHJvZHVjdGlvbiA9IHJlcXVpcmUoJy4vcHJvZHVjdGlvbicpXG5jb25zdCBwcmljaW5nID0gcmVxdWlyZSgnLi9wcmljaW5nJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFBST0RVQ0VfQ0xJUDogcHJvZHVjdGlvbi5wcm9kdWNlLFxuICBTRUxMX0NMSVA6IHByb2R1Y3Rpb24uc2VsbCxcbiAgSU5DUkVBU0VfUFJJQ0U6IHByaWNpbmcuaW5jcmVhc2UsXG4gIERFQ1JFQVNFX1BSSUNFOiBwcmljaW5nLmRlY3JlYXNlXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RvcmUvbXV0YXRpb25zL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByb2R1Y2Uoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUud2lyZS5zdG9jayA+IDApIHtcbiAgICAgIHN0YXRlLmNsaXAuY291bnQrK1xuICAgICAgc3RhdGUuY2xpcC5zdG9jaysrXG4gICAgICBzdGF0ZS53aXJlLnN0b2NrLS1cbiAgICB9XG4gIH0sXG5cbiAgc2VsbChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jbGlwLnN0b2NrID4gMCkge1xuICAgICAgc3RhdGUuY2xpcC5zdG9jay0tXG4gICAgICBzdGF0ZS5zdGF0cy5mdW5kcyArPSBzdGF0ZS5jbGlwLnByaWNlXG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RvcmUvbXV0YXRpb25zL3Byb2R1Y3Rpb24uanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5jcmVhc2Uoc3RhdGUpIHtcbiAgICBzdGF0ZS5jbGlwLnByaWNlICs9IHN0YXRlLnZhcmlhdGlvbi5jbGlwUHJpY2VcbiAgICBzdGF0ZS5zdGF0cy5kZW1hbmQgPSBzdGF0ZS5zdGF0cy5kZW1hbmQgLSAoc3RhdGUuc3RhdHMuZGVtYW5kICogc3RhdGUudmFyaWF0aW9uLmRlbWFuZClcbiAgfSxcblxuICBkZWNyZWFzZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jbGlwLnByaWNlID4gMC4wMSkge1xuICAgICAgc3RhdGUuY2xpcC5wcmljZSAtPSBzdGF0ZS52YXJpYXRpb24uY2xpcFByaWNlXG4gICAgICBzdGF0ZS5zdGF0cy5kZW1hbmQgPSBzdGF0ZS5zdGF0cy5kZW1hbmQgKyAoc3RhdGUuc3RhdHMuZGVtYW5kICogc3RhdGUudmFyaWF0aW9uLmRlbWFuZClcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zdG9yZS9tdXRhdGlvbnMvcHJpY2luZy5qcyIsImNvbnN0IGNoYW5jZXMgPSByZXF1aXJlKCcuL2NoYW5jZXMnKVxuY29uc3Qgc2FsZXMgPSByZXF1aXJlKCcuL3NhbGVzJykoY2hhbmNlcylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0YXJ0KHN0b3JlKSB7XG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIEVuZ2luZScpXG4gICAgY29uc3QgZW5naW5lTG9vcCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHNhbGVzLnN0YXJ0KHN0b3JlKVxuICAgIH0sIDEwMDApXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbmdpbmUvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IChnZW5lcmF0b3IgPSBNYXRoKSA9PiBnZW5lcmF0b3IucmFuZG9tKClcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbmdpbmUvY2hhbmNlcy5qcyIsIm1vZHVsZS5leHBvcnRzID0gY2hhbmNlcyA9PiAoe1xuICBzdGFydChzdG9yZSkge1xuICAgIGNvbnN0IGNoYW5jZSA9IGNoYW5jZXMoKVxuICAgIGlmIChjaGFuY2UgPD0gc3RvcmUuc3RhdGUuc3RhdHMuZGVtYW5kKSB7XG4gICAgICBjb25zb2xlLmxvZyhgU2FsZSBmb3IgZGVtYW5kICR7c3RvcmUuc3RhdGUuc3RhdHMuZGVtYW5kfSB3aXRoIGNoYW5jZSAke2NoYW5jZX1gKVxuICAgICAgcmV0dXJuIHN0b3JlLmNvbW1pdCgnU0VMTF9DTElQJylcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgTm8gc2VsbCBmb3IgcmF0ZSAke3N0b3JlLnN0YXRlLnN0YXRzLmRlbWFuZH0gd2l0aCBjaGFuY2UgJHtjaGFuY2V9YClcbiAgfVxufSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbmdpbmUvc2FsZXMuanMiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTJkOTAxNmZjXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vTWFpbi52dWVcIilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL01haW4udnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0yZDkwMTZmY1xcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9NYWluLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG4gIHZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01haW4udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yZDkwMTZmY1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTJkOTAxNmZjXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9NYWluLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTJkOTAxNmZjXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vTWFpbi52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjRjMTZiNTk2XCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTJkOTAxNmZjXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vTWFpbi52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMmQ5MDE2ZmNcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9NYWluLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0yZDkwMTZmY1wiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NYWluLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbioge1xcbiAgZm9udC1mYW1pbHk6ICdPcGVuIFNhbnMnLCBzYW5zLXNlcmlmO1xcbn1cXG5oMSwgaDIsIGgzLCBoNCwgaDUsIGg2IHtcXG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9Vc2Vycy9jb25mZXJlbmNlL3dzcGFjZS9zaWRlLXByb2plY3RzL3BhcGVyLWNsaXBzL3NyYy9jb21wb25lbnRzL3NyYy9jb21wb25lbnRzL01haW4udnVlPzE2NDRkNDI1XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUF1QkE7RUFDQSxxQ0FBQTtDQUNBO0FBRUE7RUFDQSwwQkFBQTtFQUNBLGtCQUFBO0NBQ0FcIixcImZpbGVcIjpcIk1haW4udnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gIDxkaXY+XFxuICAgIDxDbGlwQ291bnRlcj48L0NsaXBDb3VudGVyPlxcbiAgICA8UHJvZHVjZUNsaXA+PC9Qcm9kdWNlQ2xpcD5cXG4gICAgPGgzPk9wZXJhdGlvbnM8L2gzPlxcbiAgICA8T3BlcmF0aW9uU3RhdHVzPjwvT3BlcmF0aW9uU3RhdHVzPlxcbiAgICA8aDM+TWFudWZhY3R1cmluZzwvaDM+XFxuICAgIDxXaXJlU3RhdHVzPjwvV2lyZVN0YXR1cz5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5pbXBvcnQgQ2xpcENvdW50ZXIgZnJvbSAnLi9DbGlwQ291bnRlci52dWUnXFxuaW1wb3J0IFByb2R1Y2VDbGlwIGZyb20gJy4vUHJvZHVjZUNsaXAudnVlJ1xcbmltcG9ydCBPcGVyYXRpb25TdGF0dXMgZnJvbSAnLi9PcGVyYXRpb25TdGF0dXMudnVlJ1xcbmltcG9ydCBXaXJlU3RhdHVzIGZyb20gJy4vV2lyZVN0YXR1cy52dWUnXFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgY29tcG9uZW50czoge0NsaXBDb3VudGVyLCBQcm9kdWNlQ2xpcCwgT3BlcmF0aW9uU3RhdHVzLCBXaXJlU3RhdHVzfVxcbn1cXG48L3NjcmlwdD5cXG5cXG48c3R5bGU+XFxuKiB7XFxuICBmb250LWZhbWlseTogJ09wZW4gU2FucycsIHNhbnMtc2VyaWY7XFxufVxcblxcbmgxLCBoMiwgaDMsIGg0LCBoNSwgaDYge1xcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0yZDkwMTZmY1wiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NYWluLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcyIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8Q2xpcENvdW50ZXI+PC9DbGlwQ291bnRlcj5cbiAgICA8UHJvZHVjZUNsaXA+PC9Qcm9kdWNlQ2xpcD5cbiAgICA8aDM+T3BlcmF0aW9uczwvaDM+XG4gICAgPE9wZXJhdGlvblN0YXR1cz48L09wZXJhdGlvblN0YXR1cz5cbiAgICA8aDM+TWFudWZhY3R1cmluZzwvaDM+XG4gICAgPFdpcmVTdGF0dXM+PC9XaXJlU3RhdHVzPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ2xpcENvdW50ZXIgZnJvbSAnLi9DbGlwQ291bnRlci52dWUnXG5pbXBvcnQgUHJvZHVjZUNsaXAgZnJvbSAnLi9Qcm9kdWNlQ2xpcC52dWUnXG5pbXBvcnQgT3BlcmF0aW9uU3RhdHVzIGZyb20gJy4vT3BlcmF0aW9uU3RhdHVzLnZ1ZSdcbmltcG9ydCBXaXJlU3RhdHVzIGZyb20gJy4vV2lyZVN0YXR1cy52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge0NsaXBDb3VudGVyLCBQcm9kdWNlQ2xpcCwgT3BlcmF0aW9uU3RhdHVzLCBXaXJlU3RhdHVzfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbioge1xuICBmb250LWZhbWlseTogJ09wZW4gU2FucycsIHNhbnMtc2VyaWY7XG59XG5cbmgxLCBoMiwgaDMsIGg0LCBoNSwgaDYge1xuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICBmb250LXdlaWdodDogYm9sZDtcbn1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvTWFpbi52dWU/MTY0NGQ0MjUiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTI4MDBjMzk5XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vQ2xpcENvdW50ZXIudnVlXCIpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIilcbi8qIHNjcmlwdCAqL1xuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9DbGlwQ291bnRlci52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCBfX3Z1ZV90ZW1wbGF0ZV9fIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTI4MDBjMzk5XFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL0NsaXBDb3VudGVyLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG4gIHZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0NsaXBDb3VudGVyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMjgwMGMzOTlcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0yODAwYzM5OVwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvQ2xpcENvdW50ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMjgwMGMzOTlcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9DbGlwQ291bnRlci52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjMyYmVjZDJmXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTI4MDBjMzk5XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vQ2xpcENvdW50ZXIudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTI4MDBjMzk5XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vQ2xpcENvdW50ZXIudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTI4MDBjMzk5XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL0NsaXBDb3VudGVyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJmaWxlXCI6XCJDbGlwQ291bnRlci52dWVcIixcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0yODAwYzM5OVwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9DbGlwQ291bnRlci52dWVcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJoMVwiLCBbXG4gICAgX3ZtLl92KFwiQ2xpcHMgcHJvZHVjZWQ6IFwiICsgX3ZtLl9zKF92bS4kc3RvcmUuc3RhdGUuY2xpcC5jb3VudCkpXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmV4cG9ydCBkZWZhdWx0IGVzRXhwb3J0c1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0yODAwYzM5OVwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTI4MDBjMzk5XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL0NsaXBDb3VudGVyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL1Byb2R1Y2VDbGlwLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IF9fdnVlX3RlbXBsYXRlX18gZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZjA4ODc1NDZcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vUHJvZHVjZUNsaXAudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbiAgdmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9Qcm9kdWNlQ2xpcC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWYwODg3NTQ2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtZjA4ODc1NDZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL1Byb2R1Y2VDbGlwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxidXR0b24gQGNsaWNrPVwiUFJPRFVDRV9DTElQXCIgOmRpc2FibGVkPVwiJHN0b3JlLnN0YXRlLndpcmUuc3RvY2sgPCAxXCI+UHJvZHVjZSBQYXBlcmNsaXA8L2J1dHRvbj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHttYXBNdXRhdGlvbnN9IGZyb20gJ3Z1ZXgnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbWV0aG9kczogbWFwTXV0YXRpb25zKFsnUFJPRFVDRV9DTElQJ10pXG59XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9Qcm9kdWNlQ2xpcC52dWU/NTRjOGYxYjciLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIFtcbiAgICBfYyhcbiAgICAgIFwiYnV0dG9uXCIsXG4gICAgICB7XG4gICAgICAgIGF0dHJzOiB7IGRpc2FibGVkOiBfdm0uJHN0b3JlLnN0YXRlLndpcmUuc3RvY2sgPCAxIH0sXG4gICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uUFJPRFVDRV9DTElQIH1cbiAgICAgIH0sXG4gICAgICBbX3ZtLl92KFwiUHJvZHVjZSBQYXBlcmNsaXBcIildXG4gICAgKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5leHBvcnQgZGVmYXVsdCBlc0V4cG9ydHNcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtZjA4ODc1NDZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1mMDg4NzU0NlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9Qcm9kdWNlQ2xpcC52dWVcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIilcbi8qIHNjcmlwdCAqL1xuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9PcGVyYXRpb25TdGF0dXMudnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi05NmNhY2I3NFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9PcGVyYXRpb25TdGF0dXMudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbiAgdmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9PcGVyYXRpb25TdGF0dXMudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi05NmNhY2I3NFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTk2Y2FjYjc0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9PcGVyYXRpb25TdGF0dXMudnVlXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPHA+QXZhaWxhYmxlIGZ1bmRzOiAke3twYXJzZUZsb2F0KCRzdG9yZS5zdGF0ZS5zdGF0cy5mdW5kcykudG9GaXhlZCgyKX19PC9wPlxuICAgIDxwPlN0b2NrIGNvdW50OiB7eyRzdG9yZS5zdGF0ZS5jbGlwLnN0b2NrfX08L3A+XG4gICAgPHA+Q2xpcCBQcmljZToge3twYXJzZUZsb2F0KCRzdG9yZS5zdGF0ZS5jbGlwLnByaWNlKS50b0ZpeGVkKDIpfX08L3A+XG4gICAgPHA+UHVibGljIERlbWFuZDoge3twYXJzZUZsb2F0KCRzdG9yZS5zdGF0ZS5zdGF0cy5kZW1hbmQgKiAxMDApLnRvRml4ZWQoMil9fSU8L3A+XG4gICAgPENsaXBQcmljZUNvbnRyb2w+PC9DbGlwUHJpY2VDb250cm9sPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ2xpcFByaWNlQ29udHJvbCBmcm9tICcuL0NsaXBQcmljZUNvbnRyb2wudnVlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtDbGlwUHJpY2VDb250cm9sfVxufVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvT3BlcmF0aW9uU3RhdHVzLnZ1ZT8wNDY0OWMwMSIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIilcbi8qIHNjcmlwdCAqL1xuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9DbGlwUHJpY2VDb250cm9sLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IF9fdnVlX3RlbXBsYXRlX18gZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMjViNTNhZjJcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vQ2xpcFByaWNlQ29udHJvbC52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xuICB2YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0NsaXBQcmljZUNvbnRyb2wudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yNWI1M2FmMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTI1YjUzYWYyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9DbGlwUHJpY2VDb250cm9sLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxidXR0b24gQGNsaWNrPVwiREVDUkVBU0VfUFJJQ0VcIiA6ZGlzYWJsZWQ9XCIkc3RvcmUuc3RhdGUuY2xpcC5wcmljZSA8PSAgMC4wMVwiPlJlZHVjZSBQcmljZTwvYnV0dG9uPlxuICAgIDxidXR0b24gQGNsaWNrPVwiSU5DUkVBU0VfUFJJQ0VcIj5JbmNyZWFzZSBQcmljZTwvYnV0dG9uPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge21hcE11dGF0aW9uc30gZnJvbSAndnVleCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBtZXRob2RzOiBtYXBNdXRhdGlvbnMoWydJTkNSRUFTRV9QUklDRScsICdERUNSRUFTRV9QUklDRSddKVxufVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvQ2xpcFByaWNlQ29udHJvbC52dWU/NDY1YmE4MDQiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIFtcbiAgICBfYyhcbiAgICAgIFwiYnV0dG9uXCIsXG4gICAgICB7XG4gICAgICAgIGF0dHJzOiB7IGRpc2FibGVkOiBfdm0uJHN0b3JlLnN0YXRlLmNsaXAucHJpY2UgPD0gMC4wMSB9LFxuICAgICAgICBvbjogeyBjbGljazogX3ZtLkRFQ1JFQVNFX1BSSUNFIH1cbiAgICAgIH0sXG4gICAgICBbX3ZtLl92KFwiUmVkdWNlIFByaWNlXCIpXVxuICAgICksXG4gICAgX3ZtLl92KFwiIFwiKSxcbiAgICBfYyhcImJ1dHRvblwiLCB7IG9uOiB7IGNsaWNrOiBfdm0uSU5DUkVBU0VfUFJJQ0UgfSB9LCBbXG4gICAgICBfdm0uX3YoXCJJbmNyZWFzZSBQcmljZVwiKVxuICAgIF0pXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmV4cG9ydCBkZWZhdWx0IGVzRXhwb3J0c1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0yNWI1M2FmMlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTI1YjUzYWYyXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL0NsaXBQcmljZUNvbnRyb2wudnVlXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgW1xuICAgICAgX2MoXCJwXCIsIFtcbiAgICAgICAgX3ZtLl92KFxuICAgICAgICAgIFwiQXZhaWxhYmxlIGZ1bmRzOiAkXCIgK1xuICAgICAgICAgICAgX3ZtLl9zKHBhcnNlRmxvYXQoX3ZtLiRzdG9yZS5zdGF0ZS5zdGF0cy5mdW5kcykudG9GaXhlZCgyKSlcbiAgICAgICAgKVxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJwXCIsIFtfdm0uX3YoXCJTdG9jayBjb3VudDogXCIgKyBfdm0uX3MoX3ZtLiRzdG9yZS5zdGF0ZS5jbGlwLnN0b2NrKSldKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcInBcIiwgW1xuICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgXCJDbGlwIFByaWNlOiBcIiArXG4gICAgICAgICAgICBfdm0uX3MocGFyc2VGbG9hdChfdm0uJHN0b3JlLnN0YXRlLmNsaXAucHJpY2UpLnRvRml4ZWQoMikpXG4gICAgICAgIClcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwicFwiLCBbXG4gICAgICAgIF92bS5fdihcbiAgICAgICAgICBcIlB1YmxpYyBEZW1hbmQ6IFwiICtcbiAgICAgICAgICAgIF92bS5fcyhwYXJzZUZsb2F0KF92bS4kc3RvcmUuc3RhdGUuc3RhdHMuZGVtYW5kICogMTAwKS50b0ZpeGVkKDIpKSArXG4gICAgICAgICAgICBcIiVcIlxuICAgICAgICApXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcIkNsaXBQcmljZUNvbnRyb2xcIilcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5leHBvcnQgZGVmYXVsdCBlc0V4cG9ydHNcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtOTZjYWNiNzRcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi05NmNhY2I3NFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9PcGVyYXRpb25TdGF0dXMudnVlXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbnZhciBfX3Z1ZV9zY3JpcHRfXyA9IG51bGxcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi00NTY1OGE0Y1xcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9XaXJlU3RhdHVzLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG4gIHZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBudWxsXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvV2lyZVN0YXR1cy52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQ1NjU4YTRjXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDU2NThhNGNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL1dpcmVTdGF0dXMudnVlXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgYXR0cnM6IHsgaWQ6IFwid2lyZS1zdGF0dXNcIiB9IH0sIFtcbiAgICBfYyhcInBcIiwgW192bS5fdihcIldpcmUgc3RvY2s6IFwiICsgX3ZtLl9zKF92bS4kc3RvcmUuc3RhdGUud2lyZS5zdG9jaykpXSksXG4gICAgX3ZtLl92KFwiIFwiKSxcbiAgICBfYyhcInBcIiwgW1xuICAgICAgX3ZtLl92KFxuICAgICAgICBcIkJhdGNoIFByaWNlOiAkXCIgK1xuICAgICAgICAgIF92bS5fcyhfdm0uJHN0b3JlLnN0YXRlLndpcmUuYmFzZVByaWNlLnRvRml4ZWQoMikpICtcbiAgICAgICAgICBcIiBmb3IgXCIgK1xuICAgICAgICAgIF92bS5fcyhfdm0uJHN0b3JlLnN0YXRlLndpcmUuYmF0Y2hTaXplKSArXG4gICAgICAgICAgXCIgaW5jaGVzXCJcbiAgICAgIClcbiAgICBdKSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgIF9jKFwiYnV0dG9uXCIsIFtfdm0uX3YoXCJCdXlcIildKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5leHBvcnQgZGVmYXVsdCBlc0V4cG9ydHNcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNDU2NThhNGNcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00NTY1OGE0Y1wiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9XaXJlU3RhdHVzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIFtcbiAgICAgIF9jKFwiQ2xpcENvdW50ZXJcIiksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJQcm9kdWNlQ2xpcFwiKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImgzXCIsIFtfdm0uX3YoXCJPcGVyYXRpb25zXCIpXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJPcGVyYXRpb25TdGF0dXNcIiksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJoM1wiLCBbX3ZtLl92KFwiTWFudWZhY3R1cmluZ1wiKV0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiV2lyZVN0YXR1c1wiKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmV4cG9ydCBkZWZhdWx0IGVzRXhwb3J0c1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0yZDkwMTZmY1wiLCBlc0V4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTJkOTAxNmZjXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01haW4udnVlXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9